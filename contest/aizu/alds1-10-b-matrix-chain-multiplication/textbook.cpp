// Accepted.
#include <algorithm>
#include <iostream>
using namespace std;

static const int N = 100;	// 入力される行列の数の最大値である。

int main(void)
{
	int n, p[N + 1], m[N + 1][N + 1];
	cin >> n;	// [1, 100]
	for (int i = 1; i <= n; ++i)
		cin >> p[i - 1] >> p[i];	// 行列の辺の長さを表します。行列 M[i] は p[i - 1]×p[i] 行列です。連続して与えられる 2 つの行列の列数と行数は一致するので、それぞれ記録することはしません。
	for (int i = 1; i <= n; ++i)
		m[i][i] = 0;	// m[i][j] は、行列 M[i] から M[j] までについての連鎖行列積の最小乗算回数です。同一の行列 M[i] 同士については、計算の必要がないので乗算回数 0 回です。
	for (int l = 2; l <= n; ++l) {	// まずは 2 つの行列について考えます。
		for (int i = 1; i <= n - l + 1; ++i) {	// 左から行列の組を見ていきます。
			int j = i + l - 1;	// 行列の組の右端の添字です。
			m[i][j] = 1 << 21;	// 非常に大きな値で初期化します。
			for (int k = i; k <= j - 1; ++k) {	// 切る場所を考えます。
				m[i][j] = min(m[i][j], m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]);	// m[i][k] は左側部分の最小乗算回数です。m[k + 1][j] は右側部分の最小乗算回数です。左側は p[i - 1] * p[k] 行列であり、右側は p[k] * p[j] 行列なので、位置 k で切った場合に今回追加される乗算回数は p[i - 1] * p[k] * p[j] です。最も良い切断箇所を求めます。
			}
		}
	}
	cout << m[1][n] << endl;	// 行列 M[1] から M[n] まで、つまり全体についての最小乗算回数が答えになります。
	return 0;
}
