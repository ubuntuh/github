### 2015-12-27 Sun

- insertion sort というものを、設問の擬似コードに従って C++ で実装した。
- Haskell でも、一応動作するものを実装してみたが、C++ で実装するよりもずっと読みにくく、機能的にもデメリットはありえてもメリットは考えられないであろうものになった。
- 他に 2 人、Haskell で submit されたコードを公開していたので、勉強させていただいた。私には難しく、とてもうまく Haskell を使いこなしているように見えたが、しかし insertion sort について Haskell で実装することを有意義とまでは感じられなかった。
- insertion sort の前半部分が整列済みになっている、という論理を、Haskell が表すことは感じられた。
- しかし、計算効率を考えたアルゴリズムであろうから、破壊的代入を捨象（無視？）した記述は、不満足な感じもする。破壊的代入をしっかり書きたい気もするが、Haskell でその方法はあるらしいが知らないのと、だったら C++ でいいということがある。
- ネストしたループについて、カウンタ全てを引数とする再帰関数で実装したと思うのだが、性能においても可読性においても悪いだろう。
- Haskell で書くのには悩んだが、書けたので、練習にはなったろう。
- おそらく、多数のカウンタを引数として再帰でごりごり回すのは、Haskell らしくない。読みやすくないし、C++ でやる方が効率的で簡潔に書けるだろう。
- しかし、C++ などを想定した擬似コードを、多数のカウンタを用いて何やら少し強引な感じで Haskell で実装してしまう方法はわかった。
- emacs で Haskell 書いたが、支援機能がパースエラー起こすらしく、そうなるとインデント機能が消滅して、空白を連打する必要があり、使いにくかった。emacs は使いにくい。
- Haskell に適さない？コードを書く場合にも、自分で多少納得がいくだけ整理されたコードを書けるようになっていきたい。
- テストデータが小さいからやっと動作している気がしてならない。
