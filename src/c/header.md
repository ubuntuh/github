# Header Files

### 2016-02-01 Mon

* C 言語にはヘッダファイルというものがある。が、よくわからない。
* C preprocessor (cpp) というものがある。実際、cpp という実行ファイルとして存在している。これが、#include などの # で始まる行 (preprocessing directive) を解釈して処理する。
* #include は、そのテキストファイルのそこに、他のテキストファイルを単純に展開する命令である。よってこれにより、ファイルを分割することができる。また一方、#include を使って書けることは、理屈の上では、#include を使わずにも書ける。#include が使われるのは、複数のソースコードについて同じソースコードを共有したい場合であると言える。
* #include は、ソースファイルの冒頭で使ってヘッダファイルをインクルードする使い方が普通だが、そうではなく、ファイルの末尾で関数を定義することも可能である。また、文の途中で別のファイルに分離することも可能である。
* 逆に言えば、あえて適切に使わねばならない。
* なお、gcc で -E オプションを使うと、プリプロセス後のテキストを見ることができる。
* #include が使われるのは、ヘッダファイルをインクルードする場合のみである。ヘッダファイルの拡張子は .h である。.c はソースファイル。
* #include <example.h> と、#include "example.h" という形があるが、それぞれヘッダファイルのサーチパスが異なる。前者ではコンパイラに設定されたサーチパスや -I オプションで与えられるパスが使用され、後者ではそのファイルと同じディレクトリから探される。
* なぜか、#include "/usr/include/stdio.h" などという形で、絶対パスで指定できるようである。
* include というディレクトリ名は、そこにヘッダファイルが収められることを意味していいる。
* gcc に -H オプションを与えれば、具体的にどのヘッダファイルがインクルードされたのかを確認できる。また gcc -print-search-dirs とすることで、ヘッダファイルのサーチパスを知ることができる。

# 前方宣言

* 前方宣言 (forward declaration) という考え方がある。
* ソースコードの中で前後関係を考え、ある記号が使われる時にはその型が知られていなければならない、とする仕組みのことである。
* 実際には宣言と定義を離せばよいのだが、定義のみでやるなら、結果的にボトムアップな構造になる。
* 面倒なことが多く、何のためにある仕組みなのか、よくわかっていない。

# 関数のプロトタイプ宣言

* 関数のプロトタイプ宣言というものがある。
* 例えば、int f(int, int) などと書く。
* 現在ではそのように、引数の型を指定することが推奨されるが、歴史的には、返り値の型のみ指定することも許された。例えば int f() とする。こういったものは、プロトタイプ宣言とは呼ばず、単に前方宣言と呼ぶ。引数のない関数をプロトタイプ宣言したい場合には、int f(void) などとする必要がある。

# ファイル分割

* プログラムの一つのソースファイルに記述することも可能だが、普通、複数の .c ファイルに書かれる。
* それぞれの .c ファイルには関数が定義されていて、エントリーポイントである main 関数から間接的に、関数らが相互に呼び出しあうことで、一つのプログラムが実現する。
* それぞれの .c ファイルについて、ヘッダファイルが作られる。そのヘッダファイルをインクルードすることで、各 .c ファイルでは、利用したい他のファイルの関数について、プロトタイプ宣言が行えることになる。
* ヘッダファイルは、Java などにおけるインタフェースである。名前空間で依存性を操作する役割がある。
* ヘッダファイルは、対応するソースファイルからもインクルードされる。自身のための関数プロトタイプ宣言になる。
* 一つのヘッダファイルには普通、いくつものソースファイルが依存している。一つのヘッダファイルの更新が、それらソースファイルの再コンパイルを引き起こす場合もある。

# 動的リンク

* コンパイル済みの形で、ライブラリとしてプログラムが共有されることがある。shared object と呼ばれ、.so という拡張子が使われることが多い。
* gcc で共有ライブラリを作るには、-shared オプションを用いる。
* 共有ライブラリをリンクするには、gcc で -l オプションを用いる。
* ldd a.out などとして、共有ライブラリの依存関係を調べることができる。

# 定義しない

* ヘッダファイルでは、宣言するだけで、定義すべきでない。
* 変数の場合、メモリを確保してはいけない。
* 関数の場合、内容を定義してはいけない。
* ヘッダファイルで、グローバル変数を int i などと定義してはならない。なぜなら、それをそれぞれインクルードした複数のソースファイルそれぞれのオブジェクトファイルがリンクされる時に、それぞれにある同名の変数がリンクエラーを起こすからである。
* static int i とすればリンクエラーは回避されるが、それぞれのオブジェクトファイルで、公開せずに別の変数を持っているにすぎない。ヘッダファイルでこのようなことをする必要はなく、ヘッダファイルでグローバル変数に static を使う必要はない。
* 正しくは、extern int i とする。そうしておいて、対応するソースファイルの中で int i とする。これにより、繰り返し読み込まれるのは宣言のみになる。
* 関数は、ヘッダファイルの中で int f(int, int) などとする。対応するソースファイルの中でその実装を記述する。

# include guard

* include guard というものがある。
* ヘッダファイルが別のヘッダファイルをインクルードすることは普通に必要であって、その際に同じヘッダファイルの内容を重複して記述しないために、include guard が用いられる。
* 例えば、#ifndef EXAMPLE\_H #define EXAMPLE\_H ... #endif とする。
* この方法では、識別子が衝突しないようにする必要がある。
* 基本的なヘッダファイル全てにおいて、このインクルードガードが使われている。そのことは例えば cat /usr/include/stdio.h とすれば確認できる。
* #pragma once というものもあるが、gcc 3.4 以前では使えない。また、言語仕様に定められていないので、使わないほうがよい。
* プリプロセスで識別子を確認して不要な #include を避けることがパフォーマンス上、最もよいが、gcc ではそれ相当の最適化が行われるので必要ない。冗長インクルードガードまたは外部インクルードガードと呼ばれるが、識別子名が依存してしまうために設計上も好ましくない。

# 循環参照

* 相互に参照しているなどして #include がくるくる回ってしまうことを循環参照と言い、コンパイルエラーになる。
* 具体的な型が不明な場合には、ポインタとして扱ってしまえばいい。
