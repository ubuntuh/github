# C 言語はじめの一歩

- 2003 年 11 月 10 日 初版第 1 刷発行
- 豊沢聡 (Satoshi Toyosawa)
    - 1964 年生まれ。

### 第 1 章 C コンパイラのインストール

- 付属 CD-ROM から mingw をコピーする。さらに Windows の環境変数の PATH を設定する。
- cd コマンドは change directory の略である。

### 第 2 章 gcc を試してみよう

- Brian Kernighan と Dennis Ritchie が C 言語を開発した。
- 今、国際的に通用する言語というと、英語でしょう。これは、イギリスとアメリカ合衆国という英語を用いる 2 カ国が、ここ数世紀の間、世界的な覇権国家であったという至極きなくさい理由によります。
- 逆に、gcc は .c で終わるファイル名ならば、C 言語で書かれたソースファイルだと思い込み、コンパイルを開始します。ためしに、その辺にある MS-Word や PDF ファイルなどの拡張子を .doc や .pdf から .c に変えてみてください（Windows が心配して文句を言いますが、かまいません。あとで戻せばよいのですから）。

### 第 3 章 ハングマン

- Ken Arnold が hangman というゲームを考案した。
- hangman とは、首吊り役人という意味である。

<!-- -->

1. ヒントとして、単語の文字数と和訳を表示します。
2. プレーヤーはその隠された単語に含まれると推測されるアルファベット（a～z）を 1 文字入力します。大文字が入力された場合は、それを小文字として扱います。文字が複数入力されたときは、最初の文字だけを用います。
3. 2\. で入力した文字が単語に含まれていれば、単語中のその文字の位置に該当文字を表示します。
4. プレーヤーが既に使用した文字を誤って何度もトライしないように、使用済みの文字を表示します。
5. 2\. の文字が誤っていれば、誤った旨を表示し、「首吊り」のカウントダウンをします。ただし、入力された文字が既に使用された文字であったり、アルファベットではない場合は、誤りとしてカウントしません。
6. 1 つの単語に対して、2. から 5. を繰り返します。誤りが 7 回に達したら、その回はプレーヤーの負け。負けのときは、正答を表示します。
7. 1 回のプレーは 10 回（10 単語）。10 回終了後に、点数（10 点満点）を表示します。

<!-- -->

- 辞書データは、Monash University の Jim Breen 教授による EDICT を用い、さらに加工したデータを使う。
- 加工されたデータは、それぞれの行が例えば次のような内容を持っている。
- abandon 諦める, 見離す, 取り下げる, 打ち捨てる
- abandoning 放擲, 抛擲, 棄却, 断念

### 第 4 章 C 言語の枠組みとメッセージの表示

- `int main() { ... }` もまた 1 つの文 (statement) である。
- ヘッダファイル stdio.h の stdio は、standard IO という意味である。
- printf における \a は、音がならなかった。\b でのバックスペースは機能した。\f は、同じ位置で次の行に移動した。\r は機能した。\t は機能し、8 文字の幅であった。\v の垂直タブは、\f と同じ動作をした。
- C90 以前の ANSI C では、// によるコメントが定められていなかったが、C99 以降の ANSI C では定められている。

### 第 5 章 中の数字が変化するメッセージを表示する

- printf で %d を用いる。

### 第 6 章 中の文字が変化するメッセージを表示する

- 文字は単一引用符でくくり、文字列は二重引用符でくくる。
- char 配列の大きさは、収めたい文字の数よりも 1 つ多くとる。最後の要素には、文字列の終端を表す 0 が入る。
- 配列の宣言と代入は切り離せない。
- printf における %c と %s。
- ここで用いる辞書で最も文字数が大きい語は、intercommunications で、18 文字である。
- 128 MB メモリ搭載のマシンの最も最後の番地は、134,217,727 番地である。
- blue screen of death。
- p. 105 のソースのように、文字列の末尾の null 文字を破壊しても、printf でそれ以降に異常な出力がなされる様子を見ることはできなかった。たまたま直後が 0 だったのかもしれないし、現在の環境では規制されているのかもしれない。

### 第 7 章 文字列を操作する

- string.h - strlen, memset

### 第 8 章 当たり文字の判定

### 第 9 章 プレーヤーの入力

- fgets()。
- 標準入出力は 3 つある。stdin、stdout、stderr。それぞれ、standard input、standard output、standard error という意味である。
- stdout ではない出力に printf を使いたい場合、fprintf というものがある。
- 入力バッファ
- Temelkovski
- 入力バッファの不要な後半部分を破棄、flush する方法として、`fseek(stdin, SEEK_END, 0)` というものが紹介されている。しかし機能しないようだ。そもそも fseek は成功した場合には 0 を返すらしいが、-1 が返ってきている。ネットを見ると、同じことをするためには、getchar などによって 1 文字取得することを、\n か EOF が得られるまで繰り返す方法が一般的であるようである。
- user が honest だと前提するなら、単に fgets で長く取ればいい。このこと（この前提）がセキュリティ上の問題となる場合があるだろうか？　あるなら例えば？

### 第 10 章 入力ミスへの対処

- 大文字に 32 を足すと小文字になる。
- 小文字の ASCII コードは 97 から 122 の範囲にある。
- yes/no の結果を一時的に記憶しておく変数を得に「フラグ (flag)」といいます。
- p.166 のコードで、`#include <string.h>` しないと strlen と memset で gcc から warning が出た。include すれば消えるが、しなくても動いた。しかし、`#include <stdio.h>` まで削除すると、stdin と書かれたところで error となりコンパイルできなかった。

### 第 11 章 辞書ファイルを読む

- "NULL" は「空」とか「無効」という意味で、「ヌル」もしくは「ナル」と発音します。

### 第 12 章 辞書ファイルを分解する

### 第 13 章 単語を無作為に選ぶ

- stdlib.h の rand() が返す値は、テキストでは [0, 32767] が紹介されているが、システムやコンパイラによって違うとも書かれている。自らの環境の stdlib.h を見てみたら、（正しいものを見ているか不明だが、）`#define	RAND_MAX	2147483647` とあって、実際、返ってくる値はしばしば 32767 よりも大きい。コメントによると MAX_INT と同じ値であるとのこと。limits.h の MAX_INT を見ると、実際に同じ値になっている。signed int の最大値であるらしい。この値は 2^31-1 であって、unsigned int であれば 2^32 = 4294967296 が最大値。つまり int が 32 bits = 4 bytes の環境ではこの値になる。一方、2^16 = 65536 であるから、int が 16 bits = 2 bytes の環境では、RAND_MAX が 32767 なのだろう。
- srand しないか、srand(0) とした場合、私の環境では rand は、1804289383, 846930886, ... という値を返す。毎回同じ数の並びが欲しいこともある。

### 第 14 章 まとめてみよう
