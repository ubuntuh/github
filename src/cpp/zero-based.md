# Zero-based or One-based Indexing

### 2016-03-10 Wed

- 10 個の要素からなる配列を a[0] から a[9] で表す方法と、a[1] から a[10] で表す方法がある。それぞれ zero-based indexing と one-based indexing と言う。
- C 言語では、デフォルトで zero-based である。しかし、要素を 1 つ多く取っておけばその僅かなコストで one-based としても扱える場合が多い。
- one-based が有用な場合もあるように思う。
- zero-based と one-based の長所と短所を整理したい。
- / と % の仕様は変更できないことが多いだろう。a / 10 は 10 から 19 について 1 である。a % 10 は 9 について 9 であり 10 について 0 である。これについて zero-based は好ましい。
- modulo operation。
- 何もかも zero-based で押し通せるだろうか？
- pointer の計算についても zero-based がわかりやすいらしい。
- 以下のものがあるがちゃんと読んでいない。
- Wikipedia - Zero-based numbering
- Wikipedia - Index notation （添字表記法）
- 1982 - Edsger W. Dijkstra - Why numbering should start at zero
- 物を数える時は普通、1 個、2 個と言う。0 個というのは普通、無いことに対応する。
- 水が 1 liter、2 liters と言う。1 liter ずつ袋に分けると袋が 2 個である。one-based だと個数と量が対応するようである。
- zero-based では 0 が [0, 1) を表わしており、one-based では 1 が (0, 1] を表わしていると考えることができるかもしれない。
- for (int i = 1; i <= n; ++i); と書くことには魅力がある気がする。なぜなら、i は実際 1 から n にまでなるのに対して、そこに 1 と n そのものが表れているからである。
- むしろ one-based で押し通せないだろうか？

#### -

- 数学ではどちらが好まれるのだろうか？
- どちらも用いられると説明されていたが、one-based の方が好まれている気がする。ベクトル、行列。
- C++ の vector では v[i] などと添字でアクセスできる。そして、v.size() とすれば要素数が返ってくる。
- そのように、配列オブジェクトに対して size や length といった関数を利用する場合、余分な要素 v[0] を確保しておくと矛盾が生じてしまう。
- 郷に入っては郷に従え、という意味では、C 言語などの大抵のプログラミング言語の環境では、zero-based を使うのが無難であるようである。
- プログラミングコンテストでは、問題はしばしば one-based で表されるようである。それに対して、入力を受け取る側のプログラムで、scanf() した直後に --a などと修正されることが一般的である。
- one-based でそのまま使うならば、--a といったことをする必要がない。また時に、出力に際して ++a とする必要性も起きない。

#### -

- それぞれ 2 つの状態を持つ 8 個のオブジェクトを総当りする時に、次のようなコードが用いられることがある。
- for (int i = 0; i < 1 << 8; ++i) for (int j = 0; j < 8; ++j) if (i >> j & 1) ... else ...
- ここまで簡単に書けないものの、3 つ以上の状態を持つものについても同様に簡単に総当りできる。
- それはつまり、3 つの状態については 3 進数を使っているのだと考えられる。このような時、/ や % が便利である。そして one-based は使いにくい。

#### -

- ALGOL は zero-based？
- Fortran は one-based？
- Cobol は one-based？
- Basic は当初 one-based で後に自由？
- MATLAB は one-based。
- Lua は one-based。
- zero-based と one-based を切り替えることができるプログラミング言語が最も汎用性があり優れていると考えられる。しかし実際には、そのソースコードの部分を見た者にとって意味するところが不明であり、大いに有害であるらしい。

#### 負数との連続性

- 紀元前 1 年の翌年が西暦 1 年である。紀元前 1 年をそのまま西暦 -1 年として計算できないので煩わしい。
- 地下 1 階の上は 1 階である。地下 1 階をそのまま -1 階として計算できないので煩わしい。
- 年齢は 0 歳から数える。

#### binary heap

- binary heap というアルゴリズムがある。そこでの計算において、one-based による方がシンプルに書けるらしい。

#### modulo operation

- modulo operation （剰余演算）については、zero-based が全く便利に思える。
- ではなぜ数学で one-based が好まれるのか？
- なぜ、プログラミングコンテストの問題で、しばしば one-based な入力が与えられるのか？

#### -

- 一部の one-based については、歴史的な不合理だと言い切っていいのかもしれない。
- 西暦は、0 年を持たせるべきだったかもしれない。
- 日付は、0 月 0 日を持たせるべきかもしれない。
- しかしそうすると、1 月 31 日の 10 日後が 9 日にはなる。
- C 言語などでは、zero-based であり、length や size は、普通である。広く用いられているその落としどころは妥当であると思われる。
- 数学や日付について、one-based が用いられたのは、size と index の関係を直感的にするためであったと考えられる。
- C 言語などで zero-based が用いられたのは、（ポインタのためであるという議論が多く見られるもののそれはそれとして、）modulo operation を直感的にするためであったと考えられる。
- それぞれに全く現実的な合理性があるのだと考えられる。
- 数学では、添字に剰余演算する必要性が基本的に存在しない。また、zero-based にしようが one-based にしようが、その時々に定義すれば問題のないことが多い。
- プログラミングでは、計算量が問題になる。多次元の配列を 1 次元な配列として扱い、modulo operation を活用することは普通である。
- for (int i = 0; i < n; ++i) などと書かれる。ここで、i < n は i <= n - 1 とも書ける。普通前者が選ばれるのは、単にタイプが少なく見やすくもあるという理由に過ぎないのではないだろうか。
- 剰余演算やポインタ演算の必要がない場合には、size との翻訳の手間を減らすため、one-based の方が合理的だろうか？
- 実際、人気のあるプログラミング言語の多くは zero-based である。プログラミングコンテストの問題など、小さな問題については、配列を 1 つ多く取れば済む場合も多そうだが、1 つ多く取った C++ の vector の size() は、変になってしまうので、結局小細工は効かない感じがする。既存の主要な言語が zero-based であるというのはとても大きい。Basic の仕様が批判されていることを見れば、両方を許せばよいということでもないともわかる。

#### プログラムの外

- index は zero-based にしよう！、と考えて、それをできる限り徹底してみたい、と考えると、話が面倒になる。
- 例えば、ファイル名に連番をつける時、0 から始めるほうが一貫性があるという議論になる。
- しかし、現実世界のほとんどの話題では、何にせよ zero-based に連番をつけたがるのは、プログラミングをする者達だけだろう。
- size との翻訳を不要にすることには大きな合理性がある。
- ゼッケン 10 番の子供までいれば 10 人の子供が全員いる、というのはわかりやすくて問題を起こさない。
