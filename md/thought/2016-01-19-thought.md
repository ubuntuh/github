### 2016-01-19 Tue

- 事実は常に 1 つである。
- 目の前に狼がいるように見える時、実際そこに、狼がいる可能性が高い。それはすなわち、目の前に狼がいない可能性が低いということであり、あるいはまた、目の前に狼がいないことを否定することである。
- 実数 -1 以上 1 以下を出力する狼センサを考えよう。このセンサは、狼が近づいたことを、出力の大きさで表す。
- あるいは、0 か 1 を出力する狼センサを考えよう。このセンサは、近くに狼がいることを出力 1 で表す。
- 人間は、事実そのものを認知できない。認知できるのは抽象化された情報である。
- 例えば、目の前に狼が見える時、それに血が流れていることを見通すことはできない。そのため、狼に似たもの、例えば狼の絵を恐れるかもしれない。
- 人間が、あるものを狼であるか狼でないか判断する時、普通、明確な境界はない。
- 人間の中にある狼の定義は普通、様々な外見や動作の特徴を踏まえた極めて複合的なものであり、かなりの程度、具体的なものである。
- 現実は 1 つであり、私達は、共有された時間を 1 方向に進んでいる。そのことが、私達が行う推論の多くの根拠になっている。
- 例えば自分が昨日、山の上で狼を見たとしよう。そこである人が、昨日、山の上に狼がいなかったと言ったとしよう。その時、私達は、自分は昨日山の上に狼がいた世界から来て、彼は昨日山の上に狼がいなかった世界から来たのだな、とは考えない。事実は 1 つで、どちらかの認識が事実でない、と考える。
- また、そのように考えるとうまくいく。
- 現実には、まるで矛盾がない。
- 空間と時間には、まるで矛盾がないように見えるし、矛盾がないとして考えると、実際にうまくいく。少なくとも、うまくいくように見える。精度よく推測し、求めた利益が得られる。
- 実際には、より外側の世界から見たならば、空間や時間はより柔軟な存在かもしれないし、私達は何ら合理的に動けていないのかもしれない。しかし私達の視点から見れば、空間や時間は静的であり、そう考えて、世界の全ては整合していて、そこについて論理的に考えることで、私達の利益は最適化されるように見える。
- ゆえに、目の前に狼がいるように見える時、目の前に狼がいない世界が同時に成立していると考えず、そのような世界は存在しないのだと考えることが、合理的である。
- すなわち、私達が生存するために、経験則は利用できる。
- 1 秒後の世界は、1 秒前の世界と何ら無関係なものではない、と期待できる。
- 現実は式木であり、抽象化した小さな式木を計算することで、利益を増加できる。
- 人間の脳は本来、かなり具体的に計算していて、いわゆる数学的には計算していない。
- また本来、事実や論理をかなり軽視していて、脳の思考と現実との整合性は低い。
- しかし、人間の脳は、比較的進化したことで、かなり抽象的な概念をかなり柔軟に使えるようになった。そのことは、彼らを強くした。
- 例えば、集合論は、人間の脳の機能としてそのまま組み込まれているわけではないが、現実に対して有効な人間の脳の計算能力の半面は結果的に事実上、集合論である。
- あるいは、命題論理である。
- 集合論や命題論理の考え方の有用性の由来は、現実について、ある 2 つの事実が同時には言えない、という考え方の有用性である。
- 2 つの場合それぞれを 2 つに分ければ、合計で 4 つの場合について考えられるから、同じ考え方によって 2 つ以上の場合を扱える。
- 現実は、実数における 0 から 1 のように、無限に中間があって、線が引けない。それを抽象化によって、整数における 0 と 1 のように単純化することで、線が引ける。そのことが、計算量を減少させ、推測の精度を増加させる。
- 人間の脳は本来、かなり具体的に計算していて、0 か 1 というように、シンプルに言語的、記号的には計算していない。曖昧な確率的な認識の連鎖によって計算している。
- しかし、技術が発展したことなどから、個人の生存のためにそのような計算の重要性は低下し、0 か 1 というような言語的な計算の重要性が増加した。
- しかし一般に、人間が行う抽象的な計算は矛盾が多く、あまり意味がない。
- しかし現代では、自動計算機が、矛盾を否定し、矛盾のない計算を支援してくれるようになった。そのことは、私達が現実を生きる上で言わば杖の役割を果たすものと考えられる。
- ある言葉が、文脈を離れて永遠に真実であることなどありえない。
- 優れた計算機は、言葉が言葉にすぎないと知っている。
- 劣った計算機は、文脈を離れて言葉に意味があると考えることがある。
- あるアルゴリズムが万能に汎用だと考えることがある。
- しかし確かに、計算にはコストが伴うのだから、信仰は幸福のための 1 つの方法である。

#### -

- ある状況に置かれてある結果を求める時、私達は、本能や経験から導いたある戦略によって問題に挑戦する。
- 問題がある程度難しいと、人間がいくら考えても絶対に解けないが、問題がある程度易しいと、集団によって、あるいは個人によって、問題が解かれることがある。
- あるいはまた、どんなに計算力があっても絶対に解くことができない問題というものもあるだろう。しかし、現実は複雑だから、それが絶対に解けないと確認することはできないだろう。
- 迷路から出られないのは、迷路に出口がないか自分が馬鹿だからだが、そのどちらが事実か、死ぬまで知ることがない。
- 人々が、出口がないと断言する時、自ら、出口がないことを確認してみる若者は、魅力的である。
- 本能や経験は、戦略らが収められた道具箱のようなものである。目の前にある現実はいつも複雑だから、人々が道具箱から戦略を取り出す時、その取り出し方は、たいてい大いに直感的である。具体的な計算によって最初の戦略が選ばれる。
- そして、人々が考えだす時、彼らは彼らの頭の中に、彼らが抽象化によって得た式木を書いている。
- 人々は、このように考えた時、このようにうまくいったことがある、このように失敗したことがある、という多大な経験を用いて計算する。
- 人々は、様々な式木を仮定し、相互の矛盾を膨大に検証する。
- そうして、現実にうまく適合する方法を発案する。あるいは、発案した方法を検証した結果に基づいて、また考え、方法を改善する。
- 人は計算機であり、人々は計算機の集まりである。
- 人々の協調による成果は、古来の文明の進歩としてよく確認できる。

#### -

- ある簡単な問題を、複数の人々が解いた時、その解き方は無数にあっていいようにも思えるし、1 人として同じではないことが自然であるとも考えられるが、実際には大いに似ていて、しばしば全員同一である。
- そこに、数学の持つ一定の普遍性がある。
- 優れた人の解法でも、教えてもらえば、1 つ 1 つは問題が分割されていて、自分にも理解できることがある。
- そのことが、分業や和解をもたらす。
- しかし、ある程度具体的なまま計算される問題は、教えてもらっても理解することができない。
- ゆえに、脳がビットに帰着できないように、数学の普遍性も無限大ではない。数学は、誰にも必要な道具ではない。
- 一方で、計算は、いわゆる数学よりも広い概念である。数学とは言わば、抽象化して計算することだが、具体的な計算も存在するからである。
- しかし、普通の脳を持った個人が普通の生活を普通により幸福にするために、推論の方法が限られている、ということは事実である。各地の人類において歩き方の方法が限られている（というか同一である）ようにである。
- その意味で、数学が世界の共通語である、と言うことは正しい。
- また、ある程度は、宇宙の共通語だろう。水槽の左端と右端で生じた渦が同じ式で表せるように、宇宙において人類特有の属性などほとんど考えられないからである。共通性の程度は計算不可能ではないだろうが、私にはわからない。
- 宇宙が数学で書かれている、というような表現は、言いすぎだろう。しかしもしかしたら、人間が努力すれば書ける程度の数式から、宇宙に観測される全ての複雑性が再現できるのかもしれない。
- 数には不思議な性質があると言われる。それがどこから来たものなのか、私にはわからない。しかし、宇宙が始まった時、現在のありようは想像されなかったろう。数の性質も、そのように生じたものなのではないか。

#### -

- コンピュータなどで、アルゴリズムという概念が用いられる。
- アルゴリズムとは、計算や作業の入力から出力までの過程をより細かな入出力の単位に分割したものである。分割された手順、あるいは分割された計算のことである。
- しばしば、単純な処理を組み合わせて複雑な処理を作れるし、複雑な処理をより普遍的な処理らに分割して、計算しやすくできる。
- 例えば、10 進数の自然数について、1 桁の足し算ができる者が、複数の桁の足し算を行うためにはどうすればいいだろうか？
- すでに実現されている処理であっても、あえてより詳細に分解し、アルゴリズムに抽象化できることが多い。
- また、ソフトウェア開発において、多くの仕様は、アルゴリズムの抽象化を経て初めて実現される。
- アルゴリズムの正しさは、時に自明である。
- あるいはまた、仕様として求められる入力全てに対する出力を確認することで、アルゴリズムに従った実装の正しさを検証できる。
- しかし実際にはほとんどの場合、入力全てについて出力を確認できるだけの計算力は得られない。
- そのため、アルゴリズムの正しさを確認したい、証明したいという論点が生じる。
- アルゴリズム自身は、その正しさを証明しない。より正確に言えば、無限大の計算力を持つ計算機から見れば、あるアルゴリズムは明らかに正しいか正しくないのだが、計算力の低い計算機や人間から見れば、そのアルゴリズムの正しさ（あるいは誤り）は自明ではない。
- そのため、アルゴリズムの正しさを計算するための計算の計算量を減少する努力が行われる。
- そのためには様々な方法があるらしいが、知らない。
- アルゴリズムを考える、言わば、アルゴリズム化する、とは、一纏まりの計算や処理を与えられて、それが（正しく）分割された計算や処理を出力することである。
- 分割された計算を合成することは、しばしば関数の合成として表される。また逆に、計算を分割することは、関数の分割と呼べるだろう。アルゴリズムを求めることは、関数分割である。
- 計算や処理を、分割して考えることができない場合もある。それは、具体的にしか計算や処理ができない場合である。経験や慣れが大切であると言われる作業はしばしば、そうである。
- アルゴリズムを考えることとその正しさを証明していくこととは、しばしば同時に行われるが、しばしば個別に行われる。

#### -

- 証明とは、与えられた前提を演繹すれば結論が言えることを言うことである。
- もし無限大の計算力があれば、証明すべきものは全て自明であって、証明は必要ないと考えられる。
- 実際の証明は普通、ある前提と結論の間を、すでに証明された変形に分割することである。
- すなわち関数分割であって、証明はアルゴリズムの一種であると考えられる。
- 現代のソフトウェア開発では普通、アルゴリズムは比較的、プログラムコードの実装に表れるのに対して、そのアルゴリズムの正しさの証明のほとんどは人間が自然言語や数学で記述する。
- しかしそれでは、証明が仮に正しくても、その証明と実装との意図せぬ乖離によってバグが生じ、時に人命が失われるために、証明を実装に食い込ませる努力が行われる。
- よってそこでは普通、動作のための最低限のコードに対して、動作のためには必要のない制約を表すコードを多く追加していくことになる。
- 単純なテストも、その一種である。
- もし、正しいアルゴリズムを実装できたのであれば、そのアルゴリズムを人間が算出する過程において、正しい証明の算出が存在した場合が多いだろう。
- ゆえに、自らの考えを言葉に変換する作文の能力は、大切である。
- 証明で実装を制約するためにも、証明の存在が前提になるからである。
- 自然言語よりも数学的な方法であるものを記述しようとすると、普通、ずっと長くなる。普通、人間にとっての可読性は低下してしまう。
- コンピュータが自然言語を理解してくれれば便利だが、それはまだ現実的ではないし、脅威でもある。あるいはみじめである。
- 自然言語や数学によって、すでにある前提を利用すれば解ける問題を記述した時、ただそれだけによって、解である実装を提供してくれる環境があったならば、それが理想的に高級なプログラミング言語であると言えよう。
- しかし実際には、人間が証明によって問題を分割し、さらにアルゴリズムとして記述しなければ、コンピュータは計算できない。プログラミング言語が低級である分だけ、つまりコンピュータの知性が人間に劣る分だけ、人間が補ってやらねば、人間が行う計算を人間以上に代替させることはできない。

#### -

- コンピュータを使うと、処理を自動化できるので便利である。
- 多くの作業や計算は、それが 1 回きりであったり、入力が小さかった場合には、自動化するまでもなく簡単である。
- 例えば、入力も出力も数種類にすぎない関数を実装するのは簡単である。その正しさも、自明である。
- しかし、入力がある程度大きくなると、それぞれについて場合分けするとコードは長くなり、見通しが悪くなって正しさも明らかでなくなる。
- そのような場合に、複数の場合をまとめて扱う条件分岐や反復を用いると、見通しが改善する場合が多い。
- またそうすることによって、全ての場合を列挙することが難しいような問題についても、実装しやすくなる。
- 普通、問題は、小さいほうが考えやすい。
- よって、プログラミングにおいては、入力が小さい場合から考えることが行われる。
- 同様に一般に、数学などにおいて、数学的帰納法ということが行われる。
- これは、素朴に言えば、入力が小さい場合から考えて、小さな記述で多くの場合を考える方法であると思われる。
- 数学的帰納法では、証明したい命題を仮定して、ある段階が真であれば次の段階も真であることを言う。なので、正確に言えば別物な気もするが、多くの場合を少ない場合に帰納し抽象化するところが似ている。
- 数学的帰納法は帰納ではなく演繹であるとよく言われるようだが、よくわからないので考えない。普通努力するのは、証明を適用することではなく証明を求めることであるから、一種の帰納と呼んで問題がない気がする。
- 0 or 1 or 2 を、0 から 2 と書くことは、普通単に言い換えと見なされる気がするが、0 と 1 と 2 に共通する性質である「0 から 2」を見出すことに成功しているので、帰納であり抽象化であると考えても良い気がする。ただし、数学的な空間で行っているので、失ったものがない。
- その際、複数の場合を簡単に表そうとした時に、その正しさを示す必要性が生じる。
- 正しさを言う方法のうち、代表的なものの 1 つが数学的帰納法である。
- 定義 f(1) = 2 and f(2) = 3 は、文字通り「代数」を用いて一般に、for x in {1, 2}, f(x) = x + 1 と表せる。これを証明する方法の 1 つは、定義域の値それぞれを x に代入してみることである。
- よって、定義域全体を検証するテストは、証明の一種である。
- しかし実際は、仕様によって定義域は自明ではないし、定義域は広い。よって、複数の場合を纏めて証明することが便利である。

#### -

- loop の正しさを言うために、loop invariant という考え方があり、また、loop termination condition という考え方がある。
- また似たものとして、structural induction という考え方がある。structural recursion について用いられる。
- どちらもわからないが、structural induction のほうが考えやすい気がする。
- forall x. P(x) を証明する。
- 最も小さな再帰構造について証明し、また、ある構造について正しいと仮定して、次の大きな構造でも正しいことを証明する。
- base case、inductive step ということが言われる。
- loop invariant によって partial correctness を言うことは、structural recursion について structural induction を言うことと同じである。
- 数学的帰納法や構造的帰納法によってどのような問題が証明でき、どのような問題がそうでないのか、わからない。
- 現実には、無限個の場合を正しく処理することはできないだろう。しかし、有用であることに変わりないだろう。

#### -

- 証明された真である命題を定理 (theorem) と言う。
- それを導くための仮定を公理 (axiom) と言う。
- 0 を与えられて 1 を出力するプログラムは、実行前には x = 0 という命題が真であり、実行後には y = 1 という命題が真である、と考えられる。
- プログラム y(x) = x + 1 において、入力が x = 0 であれば、出力が y = 1 であることを証明するためには、実際に x = 0 を代入して計算してみると、証明できる。
- よってまたこのプログラムにおいて、x = 0 が axiom であり、y = 1 が theorem であると言える。
- よって、ソフトウェア開発においては、axiom と theorem が与えられて、そのアルゴリズムを実装するものと見なせる。
- また企業経営においては、経営環境を axiom として与えられ、より良い業績 theorem の出力を目指すものと考えられる。
- アルゴリズムを実装するにあたっては、計算や処理を分割していく。分割そのものがアルゴリズムの実装である。
- 分割された計算の間には、（費用対効果の範囲で、）さらに細かい theorem を置いていく。
- それぞれの計算や処理について、axiom と theorem の間を式木で繋ぐ。
- 普通、それぞれの計算や処理に特有ではない、無数の axiom が実際には存在する。
- よって、書いた式木が正しいことを示すために、それら無数の axiom を用い、つまり状況一般を根拠として、演繹論理によって theorem を示す。すなわち、証明 (proof) を書く。
- 証明の最後にはしばしば Q.E.D. と記され、and Bob's your uncle と読まれる。
- 数学的でない具体的な問題については、証明は 0 か 1 ではない。確からしさ、確率 (probability) である。証明は程度問題であり、証明が増加するほどアルゴリズムの品質は高まる。
- しかし、証明を算出するにはコストがかかるから、証明を増加させるよりも、アルゴリズムを状況の変化に即応させることのほうが重要である場合もある。
- ある前提 axiom からある結論 theorem が言えないことを言うことも証明である。
- 計算するとは、式木を評価することである。
- アルゴリズムを算出するとは、トップダウンな抽象化によって式木を得ることである。
- 証明するとは、証明を算出することであり、アルゴリズムを算出した式木の正しさを計算することである。
- 普通、証明は、一つではない axiom の場合について、纏めて theorem へのアルゴリズムの妥当性を示そうとしたものである。
- 普通、要求定義は、axiom と theorem の無数の組である。

#### -

- ある状況に置かれたある人は、普通、取りうる行動のいくつかの選択肢を持っている。
- それぞれが、戦略 (strategy) あるいはアルゴリズム (algorithm) である。
- アルゴリズムを選ぶためには、それを選んだ際に得られそうな利益を、現状から推測しなければならない。その推測を行うことが、証明することである。
- 証明は、アルゴリズムについての評価である。証明するとは、あるアルゴリズムの価値を算出することであり、証明とは、算出された点数である。ただし、その点数は普通長文である。
- あるアルゴリズムを実施して、実際良い得点が得られたことは、そのアルゴリズムの価値を必ずしも証明しない。確率的には証明する。
- よって、あなたの能力を証明せよ、と言われた者において、実績よりも口先の価値が勝る場合はある。
- どんな意味でも利益に興味がなく、欲求のない人は普通いないから、誰しも常に証明している。誰しも常に、証明したアルゴリズムを実行している。
- アルゴリズムを証明することは、式木を評価し計算することである。ただし、より具体性が高いところに注目した言葉である。
- 利益を得るために式木を選ぶ時、現実が現実を計算する前に、その式木を計算して将来を予測する。同様に、アルゴリズムを証明することによって、その式木を計算する前に、その式木に様々な値が与えられた場合の計算結果を予測する。そのように、自然言語やイメージによる要求定義から、それを満たすための実装がトップダウンに導かれていく。

#### -

- 大雑把に、式木とは一般にアルゴリズムであり、計算とは一般に証明であると考えてみよう。
- 世界が最も具体的な式木の計算であるとするなら、世界は最も具体的なアルゴリズムの証明をしている。
- 1 + 2 + 3 を計算すると、(1 + 2) + 3 = 3 + 3 = 6 となる。
- 1 + 2 + 3 = 6 であることを証明するには、左辺を変形していって、自明である 6 = 6 と同値であることを示せばいい。
- 1 + 2 + 3 を証明せよとは普通言わないし、1 + 2 + 3 = 6 を計算せよとも言わない。
- 1 + 2 + 3 を計算したものは、axiom である x = 1 + 2 + 3 を簡約していったところ、思いがけず x = 6 が得られた。結果的に、theorem である x = 6 が証明できた、と言えるかもしれない。
- 1 + 2 + 3 = 6 を証明せよというのは、axiom は数や演算の定義であって、先に theorem として 1 + 2 + 3 = 6 が与えられているところから、その theorem が正しいことを言う。
- 1 + 2 + 3 の計算も、さっきのは違って、そうかもしれない。
- axiom は、重複してもいいのだろうか？　例えば、1 + 2 + 3 = 6 であることを仮定して、左辺を簡約していくと、6 = 6 と同値であって、これが真であることから、仮定 1 + 2 + 3 = 6 が真であることを言えた。仮定が theorem であることが言えたわけだが、この仮定を axiom と呼んでしまうことは、許されないことなのだろうか？
- 定義を公理 axiom と呼ぶことは、許されないことなのだろうか？
- 価値観や考え方、抽象的なモデルは、アルゴリズムである。ある考え方の有効性を計ることは、証明である。
- もしこうしたら、こういう結果になるだろう、あるいはこうやったならばこうなるだろう、などと普通、アルゴリズムと証明は平行して考えられている。しかし詳細には、アルゴリズムが先立っている。
- 計算機は証明機だと言える。コンピュータも人間も世界も証明機であると考えることができる。照明器ではない。
- 証明機は、公理を取って定理を返す。
- 証明機はアルゴリズムを証明するが、自分自身、証明やアルゴリズムを算出することもできる。
