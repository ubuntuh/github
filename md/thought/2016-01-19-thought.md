# アルゴリズムの正しさの証明

### 2016-01-19 Tue

#### 認知の事実性

- 事実は常に 1 つである。
- 目の前に狼がいるように見える時、実際そこに、狼がいる可能性が高い。それはすなわち、目の前に狼がいない可能性が低いということであり、あるいはまた、目の前に狼がいないことを否定することである。
- 実数 -1 以上 1 以下を出力する狼センサを考えよう。このセンサは、狼が近づいたことを、出力の大きさで表す。
- あるいは、0 か 1 を出力する狼センサを考えよう。このセンサは、近くに狼がいることを出力 1 で表す。
- 人間は、事実そのものを認知できない。認知できるのは抽象化された情報である。
- 例えば、目の前に狼が見える時、それに血が流れていることを見通すことはできない。そのため、狼に似たもの、例えば狼の絵を恐れるかもしれない。
- 人間が、あるものを狼であるか狼でないか判断する時、普通、明確な境界はない。
- 人間の中にある狼の定義は普通、様々な外見や動作の特徴を踏まえた極めて複合的なものであり、かなりの程度、具体的なものである。
- 現実は 1 つであり、私達は、共有された時間を 1 方向に進んでいる。そのことが、私達が行う推論の多くの根拠になっている。
- 例えば自分が昨日、山の上で狼を見たとしよう。そこである人が、昨日、山の上に狼がいなかったと言ったとしよう。その時、私達は、自分は昨日山の上に狼がいた世界から来て、彼は昨日山の上に狼がいなかった世界から来たのだな、とは考えない。事実は 1 つで、どちらかの認識が事実でない、と考える。
- また、そのように考えるとうまくいく。
- 現実には、まるで矛盾がない。
- 空間と時間には、まるで矛盾がないように見えるし、矛盾がないとして考えると、実際にうまくいく。少なくとも、うまくいくように見える。精度よく推測し、求めた利益が得られる。
- 実際には、より外側の世界から見たならば、空間や時間はより柔軟な存在かもしれないし、私達は何ら合理的に動けていないのかもしれない。しかし私達の視点から見れば、空間や時間は静的であり、そう考えて、世界の全ては整合していて、そこについて論理的に考えることで、私達の利益は最適化されるように見える。
- ゆえに、目の前に狼がいるように見える時、目の前に狼がいない世界が同時に成立していると考えず、そのような世界は存在しないのだと考えることが、合理的である。
- すなわち、私達が生存するために、経験則は利用できる。
- 1 秒後の世界は、1 秒前の世界と何ら無関係なものではない、と期待できる。
- 現実は式木であり、抽象化した小さな式木を計算することで、利益を増加できる。
- 人間の脳は本来、かなり具体的に計算していて、いわゆる数学的には計算していない。
- また本来、事実や論理をかなり軽視していて、脳の思考と現実との整合性は低い。
- しかし、人間の脳は、比較的進化したことで、かなり抽象的な概念をかなり柔軟に使えるようになった。そのことは、彼らを強くした。
- 例えば、集合論は、人間の脳の機能としてそのまま組み込まれているわけではないが、現実に対して有効な人間の脳の計算能力の半面は結果的に事実上、集合論である。
- あるいは、命題論理である。
- 集合論や命題論理の考え方の有用性の由来は、現実について、ある 2 つの事実が同時には言えない、という考え方の有用性である。
- 2 つの場合それぞれを 2 つに分ければ、合計で 4 つの場合について考えられるから、同じ考え方によって 2 つ以上の場合を扱える。
- 現実は、実数における 0 から 1 のように、無限に中間があって、線が引けない。それを抽象化によって、整数における 0 と 1 のように単純化することで、線が引ける。そのことが、計算量を減少させ、推測の精度を増加させる。
- 人間の脳は本来、かなり具体的に計算していて、0 か 1 というように、シンプルに言語的、記号的には計算していない。曖昧な確率的な認識の連鎖によって計算している。
- しかし、技術が発展したことなどから、個人の生存のためにそのような計算の重要性は低下し、0 か 1 というような言語的な計算の重要性が増加した。
- しかし一般に、人間が行う抽象的な計算は矛盾が多く、あまり意味がない。
- しかし現代では、自動計算機が、矛盾を否定し、矛盾のない計算を支援してくれるようになった。そのことは、私達が現実を生きる上で言わば杖の役割を果たすものと考えられる。
- ある言葉が、文脈を離れて永遠に真実であることなどありえない。
- 優れた計算機は、言葉が言葉にすぎないと知っている。
- 劣った計算機は、文脈を離れて言葉に意味があると考えることがある。
- あるアルゴリズムが万能に汎用だと考えることがある。
- しかし確かに、計算にはコストが伴うのだから、信仰は幸福のための 1 つの方法である。

#### 戦略の利用

- ある状況に置かれてある結果を求める時、私達は、本能や経験から導いたある戦略によって問題に挑戦する。
- 問題がある程度難しいと、人間がいくら考えても絶対に解けないが、問題がある程度易しいと、集団によって、あるいは個人によって、問題が解かれることがある。
- あるいはまた、どんなに計算力があっても絶対に解くことができない問題というものもあるだろう。しかし、現実は複雑だから、それが絶対に解けないと確認することはできないだろう。
- 迷路から出られないのは、迷路に出口がないか自分が馬鹿だからだが、そのどちらが事実か、死ぬまで知ることがない。
- 人々が、出口がないと断言する時、自ら、出口がないことを確認してみる若者は、魅力的である。
- 本能や経験は、戦略らが収められた道具箱のようなものである。目の前にある現実はいつも複雑だから、人々が道具箱から戦略を取り出す時、その取り出し方は、たいてい大いに直感的である。具体的な計算によって最初の戦略が選ばれる。
- そして、人々が考えだす時、彼らは彼らの頭の中に、彼らが抽象化によって得た式木を書いている。
- 人々は、このように考えた時、このようにうまくいったことがある、このように失敗したことがある、という多大な経験を用いて計算する。
- 人々は、様々な式木を仮定し、相互の矛盾を膨大に検証する。
- そうして、現実にうまく適合する方法を発案する。あるいは、発案した方法を検証した結果に基づいて、また考え、方法を改善する。
- 人は計算機であり、人々は計算機の集まりである。
- 人々の協調による成果は、古来の文明の進歩としてよく確認できる。

#### 数学の普遍性

- ある簡単な問題を、複数の人々が解いた時、その解き方は無数にあっていいようにも思えるし、1 人として同じではないことが自然であるとも考えられるが、実際には大いに似ていて、しばしば全員同一である。
- そこに、数学の持つ一定の普遍性がある。
- 優れた人の解法でも、教えてもらえば、1 つ 1 つは問題が分割されていて、自分にも理解できることがある。
- そのことが、分業や和解をもたらす。
- しかし、ある程度具体的なまま計算される問題は、教えてもらっても理解することができない。
- ゆえに、脳がビットに帰着できないように、数学の普遍性も無限大ではない。数学は、誰にも必要な道具ではない。
- 一方で、計算は、いわゆる数学よりも広い概念である。数学とは言わば、抽象化して計算することだが、具体的な計算も存在するからである。
- しかし、普通の脳を持った個人が普通の生活を普通により幸福にするために、推論の方法が限られている、ということは事実である。各地の人類において歩き方の方法が限られている（というか同一である）ようにである。
- その意味で、数学が世界の共通語である、と言うことは正しい。
- また、ある程度は、宇宙の共通語だろう。水槽の左端と右端で生じた渦が同じ式で表せるように、宇宙において人類特有の属性などほとんど考えられないからである。共通性の程度は計算不可能ではないだろうが、私にはわからない。
- 宇宙が数学で書かれている、というような表現は、言いすぎだろう。しかしもしかしたら、人間が努力すれば書ける程度の数式から、宇宙に観測される全ての複雑性が再現できるのかもしれない。
- 数には不思議な性質があると言われる。それがどこから来たものなのか、私にはわからない。しかし、宇宙が始まった時、現在のありようは想像されなかったろう。数の性質も、そのように生じたものなのではないか。

#### アルゴリズムへの分解

- コンピュータなどで、アルゴリズムという概念が用いられる。
- アルゴリズムとは、計算や作業の入力から出力までの過程をより細かな入出力の単位に分割したものである。分割された手順、あるいは分割された計算のことである。
- しばしば、単純な処理を組み合わせて複雑な処理を作れるし、複雑な処理をより普遍的な処理らに分割して、計算しやすくできる。
- 例えば、10 進数の自然数について、1 桁の足し算ができる者が、複数の桁の足し算を行うためにはどうすればいいだろうか？
- すでに実現されている処理であっても、あえてより詳細に分解し、アルゴリズムに抽象化できることが多い。
- また、ソフトウェア開発において、多くの仕様は、アルゴリズムの抽象化を経て初めて実現される。
- アルゴリズムの正しさは、時に自明である。
- あるいはまた、仕様として求められる入力全てに対する出力を確認することで、アルゴリズムに従った実装の正しさを検証できる。
- しかし実際にはほとんどの場合、入力全てについて出力を確認できるだけの計算力は得られない。
- そのため、アルゴリズムの正しさを確認したい、証明したいという論点が生じる。
- アルゴリズム自身は、その正しさを証明しない。より正確に言えば、無限大の計算力を持つ計算機から見れば、あるアルゴリズムは明らかに正しいか正しくないのだが、計算力の低い計算機や人間から見れば、そのアルゴリズムの正しさ（あるいは誤り）は自明ではない。
- そのため、アルゴリズムの正しさを計算するための計算の計算量を減少する努力が行われる。
- そのためには様々な方法があるらしいが、知らない。
- アルゴリズムを考える、言わば、アルゴリズム化する、とは、一纏まりの計算や処理を与えられて、それが（正しく）分割された計算や処理を出力することである。
- 分割された計算を合成することは、しばしば関数の合成として表される。また逆に、計算を分割することは、関数の分割と呼べるだろう。アルゴリズムを求めることは、関数分割である。
- 計算や処理を、分割して考えることができない場合もある。それは、具体的にしか計算や処理ができない場合である。経験や慣れが大切であると言われる作業はしばしば、そうである。
- アルゴリズムを考えることとその正しさを証明していくこととは、しばしば同時に行われるが、しばしば個別に行われる。

#### 高級言語による証明

- 証明とは、与えられた前提を演繹すれば結論が言えることを言うことである。
- もし無限大の計算力があれば、証明すべきものは全て自明であって、証明は必要ないと考えられる。
- 実際の証明は普通、ある前提と結論の間を、すでに証明された変形に分割することである。
- すなわち関数分割であって、証明はアルゴリズムの一種であると考えられる。
- 現代のソフトウェア開発では普通、アルゴリズムは比較的、プログラムコードの実装に表れるのに対して、そのアルゴリズムの正しさの証明のほとんどは人間が自然言語や数学で記述する。
- しかしそれでは、証明が仮に正しくても、その証明と実装との意図せぬ乖離によってバグが生じ、時に人命が失われるために、証明を実装に食い込ませる努力が行われる。
- よってそこでは普通、動作のための最低限のコードに対して、動作のためには必要のない制約を表すコードを多く追加していくことになる。
- 単純なテストも、その一種である。
- もし、正しいアルゴリズムを実装できたのであれば、そのアルゴリズムを人間が算出する過程において、正しい証明の算出が存在した場合が多いだろう。
- ゆえに、自らの考えを言葉に変換する作文の能力は、大切である。
- 証明で実装を制約するためにも、証明の存在が前提になるからである。
- 自然言語よりも数学的な方法であるものを記述しようとすると、普通、ずっと長くなる。普通、人間にとっての可読性は低下してしまう。
- コンピュータが自然言語を理解してくれれば便利だが、それはまだ現実的ではないし、脅威でもある。あるいはみじめである。
- 自然言語や数学によって、すでにある前提を利用すれば解ける問題を記述した時、ただそれだけによって、解である実装を提供してくれる環境があったならば、それが理想的に高級なプログラミング言語であると言えよう。
- しかし実際には、人間が証明によって問題を分割し、さらにアルゴリズムとして記述しなければ、コンピュータは計算できない。プログラミング言語が低級である分だけ、つまりコンピュータの知性が人間に劣る分だけ、人間が補ってやらねば、人間が行う計算を人間以上に代替させることはできない。

#### 場合

- コンピュータを使うと、処理を自動化できるので便利である。
- 多くの作業や計算は、それが 1 回きりであったり、入力が小さかった場合には、自動化するまでもなく簡単である。
- 例えば、入力も出力も数種類にすぎない関数を実装するのは簡単である。その正しさも、自明である。
- しかし、入力がある程度大きくなると、それぞれについて場合分けするとコードは長くなり、見通しが悪くなって正しさも明らかでなくなる。
- そのような場合に、複数の場合をまとめて扱う条件分岐や反復を用いると、見通しが改善する場合が多い。
- またそうすることによって、全ての場合を列挙することが難しいような問題についても、実装しやすくなる。
- 普通、問題は、小さいほうが考えやすい。
- よって、プログラミングにおいては、入力が小さい場合から考えることが行われる。
- 同様に一般に、数学などにおいて、数学的帰納法ということが行われる。
- これは、素朴に言えば、入力が小さい場合から考えて、小さな記述で多くの場合を考える方法であると思われる。
- 数学的帰納法では、証明したい命題を仮定して、ある段階が真であれば次の段階も真であることを言う。なので、正確に言えば別物な気もするが、多くの場合を少ない場合に帰納し抽象化するところが似ている。
- 数学的帰納法は帰納ではなく演繹であるとよく言われるようだが、よくわからないので考えない。普通努力するのは、証明を適用することではなく証明を求めることであるから、一種の帰納と呼んで問題がない気がする。
- 0 or 1 or 2 を、0 から 2 と書くことは、普通単に言い換えと見なされる気がするが、0 と 1 と 2 に共通する性質である「0 から 2」を見出すことに成功しているので、帰納であり抽象化であると考えても良い気がする。ただし、数学的な空間で行っているので、失ったものがない。
- その際、複数の場合を簡単に表そうとした時に、その正しさを示す必要性が生じる。
- 正しさを言う方法のうち、代表的なものの 1 つが数学的帰納法である。
- 定義 f(1) = 2 and f(2) = 3 は、文字通り「代数」を用いて一般に、for x in {1, 2}, f(x) = x + 1 と表せる。これを証明する方法の 1 つは、定義域の値それぞれを x に代入してみることである。
- よって、定義域全体を検証するテストは、証明の一種である。
- しかし実際は、仕様によって定義域は自明ではないし、定義域は広い。よって、複数の場合を纏めて証明することが便利である。

#### 再帰的帰納法

- loop の正しさを言うために、loop invariant という考え方があり、また、loop termination condition という考え方がある。
- また似たものとして、structural induction という考え方がある。structural recursion について用いられる。
- どちらもわからないが、structural induction のほうが考えやすい気がする。
- for all x. P(x) を証明する。
- 最も小さな再帰構造について証明し、また、ある構造について正しいと仮定して、次の大きな構造でも正しいことを証明する。
- base case、inductive step ということが言われる。
- loop invariant によって partial correctness を言うことは、structural recursion について structural induction を言うことと同じである。
- 数学的帰納法や構造的帰納法によってどのような問題が証明でき、どのような問題がそうでないのか、わからない。
- 現実には、無限個の場合を正しく処理することはできないだろう。しかし、有用であることに変わりないだろう。

#### 公理と定理

- 証明された真である命題を定理 (theorem) と言う。
- それを導くための仮定を公理 (axiom) と言う。
- 0 を与えられて 1 を出力するプログラムは、実行前には x = 0 という命題が真であり、実行後には y = 1 という命題が真である、と考えられる。
- プログラム y(x) = x + 1 において、入力が x = 0 であれば、出力が y = 1 であることを証明するためには、実際に x = 0 を代入して計算してみると、証明できる。
- よってまたこのプログラムにおいて、x = 0 が axiom であり、y = 1 が theorem であると言える。
- よって、ソフトウェア開発においては、axiom と theorem が与えられて、そのアルゴリズムを実装するものと見なせる。
- また企業経営においては、経営環境を axiom として与えられ、より良い業績 theorem の出力を目指すものと考えられる。
- アルゴリズムを実装するにあたっては、計算や処理を分割していく。分割そのものがアルゴリズムの実装である。
- 分割された計算の間には、（費用対効果の範囲で、）さらに細かい theorem を置いていく。
- それぞれの計算や処理について、axiom と theorem の間を式木で繋ぐ。
- 普通、それぞれの計算や処理に特有ではない、無数の axiom が実際には存在する。
- よって、書いた式木が正しいことを示すために、それら無数の axiom を用い、つまり状況一般を根拠として、演繹論理によって theorem を示す。すなわち、証明 (proof) を書く。
- 証明の最後にはしばしば Q.E.D. と記され、and Bob's your uncle と読まれる。
- 数学的でない具体的な問題については、証明は 0 か 1 ではない。確からしさ、確率 (probability) である。証明は程度問題であり、証明が増加するほどアルゴリズムの品質は高まる。
- しかし、証明を算出するにはコストがかかるから、証明を増加させるよりも、アルゴリズムを状況の変化に即応させることのほうが重要である場合もある。
- ある前提 axiom からある結論 theorem が言えないことを言うことも証明である。
- 計算するとは、式木を評価することである。
- アルゴリズムを算出するとは、トップダウンな抽象化によって式木を得ることである。
- 証明するとは、証明を算出することであり、アルゴリズムを算出した式木の正しさを計算することである。
- 普通、証明は、一つではない axiom の場合について、纏めて theorem へのアルゴリズムの妥当性を示そうとしたものである。
- 普通、要求定義は、axiom と theorem の無数の組である。

#### トップダウンな実装

- ある状況に置かれたある人は、普通、取りうる行動のいくつかの選択肢を持っている。
- それぞれが、戦略 (strategy) あるいはアルゴリズム (algorithm) である。
- アルゴリズムを選ぶためには、それを選んだ際に得られそうな利益を、現状から推測しなければならない。その推測を行うことが、証明することである。
- 証明は、アルゴリズムについての評価である。証明するとは、あるアルゴリズムの価値を算出することであり、証明とは、算出された点数である。ただし、その点数は普通長文である。
- あるアルゴリズムを実施して、実際良い得点が得られたことは、そのアルゴリズムの価値を必ずしも証明しない。確率的には証明する。
- よって、あなたの能力を証明せよ、と言われた者において、実績よりも口先の価値が勝る場合はある。
- どんな意味でも利益に興味がなく、欲求のない人は普通いないから、誰しも常に証明している。誰しも常に、証明したアルゴリズムを実行している。
- アルゴリズムを証明することは、式木を評価し計算することである。ただし、より具体性が高いところに注目した言葉である。
- 利益を得るために式木を選ぶ時、現実が現実を計算する前に、その式木を計算して将来を予測する。同様に、アルゴリズムを証明することによって、その式木を計算する前に、その式木に様々な値が与えられた場合の計算結果を予測する。そのように、自然言語やイメージによる要求定義から、それを満たすための実装がトップダウンに導かれていく。

#### 証明機

- 大雑把に、式木とは一般にアルゴリズムであり、計算とは一般に証明であると考えてみよう。
- 世界が最も具体的な式木の計算であるとするなら、世界は最も具体的なアルゴリズムの証明をしている。
- 1 + 2 + 3 を計算すると、(1 + 2) + 3 = 3 + 3 = 6 となる。
- 1 + 2 + 3 = 6 であることを証明するには、左辺を変形していって、自明である 6 = 6 と同値であることを示せばいい。
- 1 + 2 + 3 を証明せよとは普通言わないし、1 + 2 + 3 = 6 を計算せよとも言わない。
- 1 + 2 + 3 を計算したものは、axiom である x = 1 + 2 + 3 を簡約していったところ、思いがけず x = 6 が得られた。結果的に、theorem である x = 6 が証明できた、と言えるかもしれない。
- 1 + 2 + 3 = 6 を証明せよというのは、axiom は数や演算の定義であって、先に theorem として 1 + 2 + 3 = 6 が与えられているところから、その theorem が正しいことを言う。
- 1 + 2 + 3 の計算も、さっきのは違って、そうかもしれない。
- axiom は、重複してもいいのだろうか？　例えば、1 + 2 + 3 = 6 であることを仮定して、左辺を簡約していくと、6 = 6 と同値であって、これが真であることから、仮定 1 + 2 + 3 = 6 が真であることを言えた。仮定が theorem であることが言えたわけだが、この仮定を axiom と呼んでしまうことは、許されないことなのだろうか？
- 定義を公理 axiom と呼ぶことは、許されないことなのだろうか？
- 価値観や考え方、抽象的なモデルは、アルゴリズムである。ある考え方の有効性を計ることは、証明である。
- もしこうしたら、こういう結果になるだろう、あるいはこうやったならばこうなるだろう、などと普通、アルゴリズムと証明は平行して考えられている。しかし詳細には、アルゴリズムが先立っている。
- 計算機は証明機だと言える。コンピュータも人間も世界も証明機であると考えることができる。照明器ではない。
- 証明機は、公理を取って定理を返す。
- 証明機はアルゴリズムを証明するが、自分自身、証明やアルゴリズムを算出することもできる。

#### 人々のアルゴリズム

- 人間の生涯にとって、砂粒は常に彼よりも小さく、山は彼よりも大きい。ゆえに人は、再帰的に考えることをしにくい。
- しかし現実には、どんな小さなものよりも小さなものがあり、どんな大きなものよりも大きなものがあるように、再帰的なモデルの方がうまく現実を説明する。太古の Big Bang に由来して現在の広大な宇宙が形成されたとされるが、その恐ろしく広大な宇宙も、より広いある世界から見たならば、砂粒や原子のように小さいのだろうと考えられる。
- また、数学的帰納法に見られるように、大きなものを説明するために、再帰的な抽象化は便利である。
- しかしまた、無数の小石があってもその中に同じ形のものがないように、抽象化されない具体的な現実には、2 者の同一性はありえない。同様に、現実には再帰的な構造は存在しない。再帰的な構造は、抽象化の産物であると考えられる。
- 本質的に言えば、アルゴリズムとは、入力と出力の間にある構造のことである。
- 時刻の増加に従って世界に起こる様々な現象は、この世界の因果関係というアルゴリズムに従ってそのような現象になっているのだと考えられる。
- ブラックボックス (black box) は、入力に応じた出力を返すだけであって、中にある構造はわからない。しかし、そこに構造があるのだろうと言うことはできる。ゆえに、そのような場合にも、そこにアルゴリズムがあると言ったほうが便利だろう。
- 人間はしばしば、再帰的に見れば同じ構造に、別の名前を与える。
- 例えば、部長、課長、係長という言葉が、社会の中で異なる響きを持つ。同様に、どんな世界でも、ある程度の安定性があって、ある種の程度を便利に分類する言葉がある。例えば、激しい雨、などと言った場合に、経験的な平均が考慮されている。地震がない国の人が、「大きな地震があった」と言うのを、地震の多い国から来た人は誤解する。
- 一般的な常識を引き剥がすと何かが見える場合があり、それが見えることが便利な場合がある。
- アルゴリズムや証明について、その概念を広く応用することに、有用性があると思われる。
- 人間が、与えられた情報を抽象的なモデルに抽象化するのは、そうすることによって利益を得ようとするからである。時々に与えられる状況についてより大きな利益を得ようとするからである。ゆえに一般に、人々が用いる抽象的なモデルは全て、アルゴリズムである。
- 現実はとても複雑であって、それをそのまま考えようとすると、あまりにも計算が困難で、どうという有用な計算結果を得られない。そのために、人々は、膨大なアルゴリズムを開発してきた。例えば、大きな図書館や書店において、そこにある全ての書籍は、それぞれ異なるアルゴリズムであると考えられる。インターネットの掲示板において、そこにおける書き込み全てのそれぞれがアルゴリズムであると考えられる。
- 本来、遺伝子的にはどうという進化のない時間において、人間がこれだけ社会を変容させ、構築してくることは、困難であった。人々は常に、彼らが持つ遺伝子によっては与えられた新たな状況に対応できないという危機に晒されてきた。常に、理想的ではありえないものの、得られる最善の合理性を、集団的に実現してきた。
- それは、無数の専門家達の協力によって実現されてきた。人々それぞれの、世界の捉え方は大きく異なっていたが、そのことがむしろ、集団としての計算力を増加させた。市井の庶民それぞれが、2 人といない専門家として計算に貢献してきた。相互に否定される考え方それぞれが、相互に利益をもたらした。無数の異なるアルゴリズムが、常に現実に挑戦してきた。
- コンピュータで様々なプログラムが実行できるように、人間の脳には様々な価値観をインストールできる。
- 言わば、人間一人一人の持つメモリや CPU は微々たるものであったが、それぞれに異なるアルゴリズムがインストールされることによって、相互に利用しあい、複雑性という闇の中を何とか今日まで歩いてきた。
- 人間一人が持つことのできる世界への認知というのは、高々その程度のものであって、それは所詮、現実そのものに隔絶している。誰の持つ認知、アルゴリズムも、世界の一部の一面をあまりにも単純化したものにすぎない。
- 私の考え、アルゴリズムが正しい、と言うことは虚しい。ある考え方が、比較的に正しいことはしばしばありえるが、その考え方が現実そのものを表せていると思うなら、それは地球の猿のおごりにすぎない。それにもし、優秀な人材の持つアルゴリズムが正しかったとしても、それは普通、他者の脳には格納できない。
- 誰しも、専門家以上にはなれない。どんな力の獲得も、何らかの能力を犠牲にすることによって実現される。ある人から見て、優れた人や劣った人はありえるが、それは彼の専門分野において優れていたり劣っていたりするというまでであって、普遍的な優劣は言えない。一見無能な人が、知らない専門分野では稀な人材であることは、普通である。
- 優れた人は、世界が広いことを知っている。世界には自分が知らない専門分野が多くあって、自分が価値を計れるのは、自分という井の中の蛙が暮らす世界に限られていると知っている。劣った人は、自分の暮らす井戸が世界だと信じたまま人生を生きて人生を終える。
- 専門性についてそのような現実を知っている人々は、無知を咎められて、かえって誇る。「それは専門じゃないから知らない」と言って、少しも恥じるところがない。常識を大切にする人々を、凡才として蔑んで喜んでいる。しかしまた、自らの専門分野においては、実力主義になる。そしてどんな優れた人も、自分よりも優れた人がいることを知っている。
- 専門家達は、カーレースのレーサーに似ている。そして世界には無数の種類の車があり、それぞれについてレースが行われている。みな、とても狭い世界で生きているが、その世界で走っている時、自分の心からの価値観の中で自分自身が肯定されるため、彼らは最も幸福である。そして、町に出れば、それぞれの天才が集まって一つの庶民らになる。
- そのように、人の数だけ膨大なアルゴリズムが存在して、それら全てが相互作用し、社会機能が実現している。
- ゆえに、社会は本質的に、人間には記述不可能である。

#### 宗教と神

- 昔、ある村において、ある宗教は、単に事実だった。
- 経典に書かれた神の実在は、絶対的な、普遍的事実であった。
- 人々は、技術を発展させ、記録によって昨日の村の姿を知り、通信によって隣の村の存在を知った。そうして人々は、かつて絶対的なものと考えられた認知を、価値観として相対化していった。
- 人々は、その相対化に底があることを期待した。相対化がどこかで止まり、何か絶対的な価値が残ることを望んだ。
- しかし現実は、そんなものはないことを示した。
- 人間が、普遍的な価値であると感覚するものは、歴史的な宗教と同様に迷信でしかないと現実は告げた。
- それはつまり、万能のアルゴリズムは存在しないことを意味した。
- それはつまり、現実の複雑さそのものは人間や人間らの脳によって表せないことを意味した。
- それはつまり、獣に知性がないように人間にも知性がないことを意味した。
- それはつまり、木に意識がないように人間にも意識がないことを意味した。
- それはつまり、文脈を離れて言葉が存在しないことを意味した。
- （現実そのもの以外の）どんなアルゴリズムも、せいぜい精度よく将来を予測するだけであって、正に正確に将来を予測できない。
- どんな言論も、実効的に便宜があるだけであって、限られた範囲でしか正しくない。前提がなければ、何も言えない。
- 本来、迷信の中で生きてきた、迷信の中でしか生きられない人間という遺伝子の脳にとって、そのような現実は、計算力を超えている。
- 人間が提出する全ての命題を、現実という神は偽であると判定する。神は、厳密に言うとそれは違う、と常に言う。そんな単純じゃないと言う。
- 人々の多くは、それを、自分の全てが否定されるように感じ、自尊心が攻撃されていくことに耐えられない。ゆえに必ず、偶像を崇拝する。必ず、偽善に溺れ、我欲を愛する。
- 生命にとって、自らは特別であり、自分は生存すべきであると知覚される。しかし現実にとって、彼の生存や幸福は、何でもない。そこに言わば、見解の相違がある。
- 生命には本来、価値がない。彼らがどんなに努力しても、不確定な脅威によって全ては破壊されうる。知性を発達させた人間にとってその相対化は恐怖であり、宗教を創造する理由になった。人々は宗教の中で長く暮らしてきたが、宗教は所詮嘘だから、発達した技術によって攻撃されはじめた。
- 宗教を否定した人々は、歴史的には殺されてきた。しかし現代では、殺されまでしないこともある。それはまるで、現実が、人間の社会に攻め込んできたかである。
- それはまるで、技術という衣を纏って神が地上に降り立つかである。そしてその中心には、電子計算機による人工知能がいる。
- そのことは、人々の持つアルゴリズムを、長期的に淘汰していくと考えられる。脳の計算力は限られているが、その中では、そこそこ正しいアルゴリズムが求められるようになる。そして、現実を頂点とするより優れたアルゴリズムらに支配されることになる。現実というアルゴリズムを仰いで暮らすことになる。人間の王は、彼の召使いになる。
- もしそうなったならば、宗教を信じる人々は、歴史的な生ける文化遺産として、絶滅を危惧され、保護される範囲で生存することになるのかもしれない。
- しかしまた、現代におけるいわゆる無宗教な思想の多くは、新たな宗教にすぎないとも見なせる。

#### 計算と証明

- 何か計算をするのは、その結果が、何かに使えると思うからである。
- 結果が使えるかどうかは、結果を使ってみることで判断できる。
- 例えば、明日の天気が雨であると予測されたならば、明日になってみれば、その情報の有用性が確認できる。
- そのように、どんな将来予測も、価値を検証されている。同様に、どんな計算結果もそうである。
- そのことは、その入力についてその計算式の正しさを証明するようなものである。
- ゆえに、計算と証明はほとんど同じものだと言えるのだろう。
- 価値のない計算は行われない。ある計算が行われるのは、それに価値があると思われていたり、価値が期待された場合である。それはつまり、その計算の妥当性が、何らかの程度で証明されていたということである。
- 証明には、ブラックボックスな証明と、ホワイトボックスな証明があると考えられる。black box の proof は、定義域の全ての入力について正しい出力が確認されれば完成される。そうではない証明として white box proof があり、そこではアルゴリズムの妥当性が問われる。
- 数学的な証明は、証明されたか証明されなかったかのどちらかだろう。しかしより広義には、証明について程度を考えることもできる。例えば、半分くらい証明されたとか、99% 証明されたとかである。99% 証明されたというのは普通、数学的には全く証明されていないということになるだろう。

#### 脳という証明

- 数学的な説明をたまに読んでみるが、難しくてわからない。〜ならば〜であるから……、と書かれている時、なぜそう言えるのか、ついていくことが難しい。しばしば、より具体的な複数の場合を変数や集合で纏めて議論されるが、そういった記述が正しく読めない。慣れもあるだろうが、努力の限界も強くあるだろう。
- 個人の能力は、個体によって異なる。ある価値観から見て、優れた人もいれば、相対的に劣った人もいる。
- 大雑把に分けて、体力的な能力と、知的な能力が考えられる。現代では、過去に比べれば、知的な能力が問われる場合が多い。知的な能力は、雑に言えば、脳の個性から来ていると考えられる。
- 脳というものは、1 つのアルゴリズムであると考えられる。
- ゆえに、個人の能力は、black box proof することもできるし、white box proof することもできる。普通、併用される。
- 誰にどの程度の仕事ができるか、予測が必要になる場合がある。その時、誰にどの程度仕事ができ、誰がそうではない、と言うのはすなわち、脳というアルゴリズムについての証明を行っている。
- ある専門について有能な人材を過小評価してしまえば、すべき投資を行えないし、適性に欠ける人材に過度の期待をかけることは、互いにとって不幸でしかない。結果的に、不正確な予測がコストを増加させることになる。逆に言えば、そのコストを減少させるものが、脳についての証明であると考えることができる。
- それはまた、個体が相互に異なっていて、またその性質が変化しないことを理解することにも繋がる。共感に頼った弱い推論を是正していくことになる。同質性を要求する幼稚な肯定から、現実主義的な肯定へと発展することが期待できる。集団において、劣った人を急いで切り離す必要が減少し、優れた人が足を引っ張られることも減少して、多様性ある宥和が期待できる。
- 叶わない夢はない、ということが言われる。その考え方が便宜上正当な場合もあるだろうからここで細かく考えはしないが、実現しない過大なリターンを幻想させて、大きな落胆の待つ大きな努力をさせることは危険である。
- また、自分にとって楽しいことが他者にとっても楽しいだろうと考え、価値観の共有を強制することは危険である。主観的な愛情は偽善の別名だからである。偽善を押しつけあうことは、結果的な全体の利益を減少させるだろう。対象の喜びを望む場合、対象にとって何が喜びかを探る努力が要件となる。
- そのように、自分や他者を主観的にではなく客観的に見ようとすることは、普通、知的な進歩であり、有益である。自分というアルゴリズムや、他者というアルゴリズムを証明していくということは、そういうことであると考えられる。
- そのようにして、アルゴリズムや証明という観点を重視して、人間や社会を考えることができる。
- ある計算手順が明らかにある妥当性を満たす時、そのアルゴリズム自身が自身を証明していると見ることができる。
- そのように、ある人について彼のアルゴリズムをもし知れたならば、彼というアルゴリズム自身が、彼に何ができ何ができないかを証明しているのだとも言える。すると、理屈の上では、将来の計算可能性が増加していくと考えられる。
