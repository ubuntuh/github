# sympy

### 2016-03-23 Wed

- プログラミング言語 Python のライブラリで sympy というものがある。記号計算機能を提供する。
- 用いるためには、基本的な数学の知識が必要になる。ゆえに私が使うことは難しい。
- しかしそのコンセプトには、興味深いところがある。

#### -

- sympy で面白く思った点の一つは、CUI で（human readable に）数式が表示できることである。
- 数式と言えば、最も美しいのは latex などによる表示である。latex を簡単に使うには、web サービスなどとして MathJax を用いるのが便利である。
- IPython Notebook というものがあると聞いて、以前、少しだけ触った。興味深かったが、複雑であってシンプルでなく、汎用的に依存しつづけたいとは思わなかった。IPython Notebook で、sympy を使い latex 的に美しい数式を表示することを知った。
- 改めて思うに、IPython Notebook 上でなくても sympy は使える。terminal で python インタプリタを起動して sympy を使うと、unicode を用いて数式を表示してくれる。
- latex ほど美しくないが、意外と問題ないのではないだろうか？　CUI で動くというのは、私にとっては魅力的であった。

#### Mathematica

- Mathematica という記号計算プログラムがあって、科学者などに広く用いられているらしい。高額で高機能であるらしい。私は使ったことがない。
- Photoshop と Gimp のようなものだろうか。
- Mathematica は、1988 年に Stephen Wolfram が作った。SymPy は、2007 年に Ondrej Certik が作った。
- Mathematica では、Wolfram Language という独自の言語を使うらしい。それは短所と見ることができる。
- Mathematica は、CUI での unicode による数式の表示をサポートしているか不明である。
- sympy は Mathematica にくらべ、Python で実装されておりパフォーマンスに劣る。
- sympy は、基本的には、Mathematica の機能を追いかけているのだと見ることができる。
- しかし、ライセンスや言語などについて、多くの長所も持っている。

#### 関数電卓

- sympy は、関数電卓に似ている。
- 関数電卓は、Mathematica に似ている。

#### Python

- Python は、成功した言語である。
- C++、Python、Java、JavaScript が、成功した言語だと考えることができる。C は C++ に、C# は Java に数えてみる。native 言語、インタプリタ言語、仮想マシン言語、ウェブブラウザ言語である。
- Perl は Python に代替された、Ruby は Python に負けた、と雑に考えることができる。一方で、上の 4 つには、少なくとも結果的に住み分けがあるようである。
- Lisp と Haskell は、あまり使われていないと考える。

#### Haskell

- Haskell を少し触ったが、教養として興味深いものであった。しかしパフォーマンスの見通しが悪い。
- Haskell は、プログラミング言語が進歩すれはそれはいわゆる数学に近づいていくのだということを示しているとも思えた。非破壊的な変数、副作用のない関数。
- しかし、sympy は Python において生まれ、Haskell において生まれたのではなかった。Haskell においては、同様のものはないらしい。
- sympy の価値を仮に大きく見た場合、それは Python に対する Haskell の敗北を示しているのではないか。
- Python は充実したライブラリを持ち、高度な処理に広く実用されている。すでに実績がある。
- Python で単純な OOP を書くのは、何も面白くないと思う。大きなものを実装するためには、Java のほうが美しい言語なのではないかと思う。私は、Python の言語仕様に惹かれなかった。
- しかし、sympy の存在は、私が Python を好む理由になるのではないか？

#### 哲学

- 数学を知らない私にとっては、Mathematica や sympy は純粋に魔法である。そして、利用できないし、利用する必要性もない。
- また、魔法に見えるから限界が見えず偉大に見えるのであって、実際には、現在のコンピュータで行える記号計算の有効範囲には強い限界があるだろう。
- しかし、そのような実用性の議論を越えて、私にとっての sympy は、哲学的な意味を持っているような気がする。世界観を更新するところがある気がする。
- Mathematica もろくに知らなかった私にとっては、sympy のような機能というのは、コンピュータにできることを越えているようにも印象される。
- オープンソースな Python ライブラリであるということは、どこにでも組み込めることを意味している。

#### 数式

- 数式は、歴史的には人間のためのものであったと、雑に考えることができる。
- プログラムを実装するためには、数式からプログラミング言語へと翻訳する必要があった。また、プログラムを読む際にはプログラミング言語から数式への翻訳が必要であったと言えるが、それは一般に困難であった。
- 記号計算プログラムは、その階層を破壊する。数式によるプログラミングを可能にすることで、翻訳を不要にする。それは、歴史的には人間にのみ可能であった計算領域に、機械が侵入してくるのだとも見られる。
- 人間が行う推論の中で、数式は最も端的に論理的な部分であり、論理的であるという意味でそれ以上の部分はない。
- ゆえに数式がコンピュータにも操作可能になるということは、コンピュータが人間とある意味同等な知性にまで育ったようなものである。人間にできてまだコンピュータにできないことは膨大にあるが、逆もそうであるという意味で同等である。
- コンピュータが進歩するほど、コンピュータを見ることで、人間は宗教的な主観を離れ、鏡を見るかのように、正しく自分を見られるようになる。
- 大げさに言えば、人間が sympy を使っているのか、sympy が人間を使っているのか、不明である。
- 数式によってプログラミングすることで、人間による計算とコンピュータによる計算とが重なる。それは、人間の脳とコンピュータが融合しているのだとも考えられる。それは、人間にとっては、自らが拡張されているのだとも考えられる。

#### 感情

- 私達の持つ感情とは、そもそも何なのだろうか？、と考えさせるところが、記号計算機能にはある。
- 理知的に見れば、世界は全く必然である。なすべきことをなす時に、あえて感情を伴わせる必要があるだろうか？　高級な仕事ほど私心を殺させるところがあると見ることもできる。
- 人間には、先天的な欲求がある。それによって苦楽があり、利益や価値がある。死を恐れ、名誉を求める。
- 先天的な欲求を満足させるために尽くすことが、有意義な人生だろうか？
- 人間の知性は、部分最適のための闘争に狂った喜びを見ることに終わる。
- 一方で、コンピュータの行う推論は、論理的な誤りを起こさない。超越的なほどに正直である。
- コンピュータは人間の脳にとって鏡であり、真理を見せることによって心の苦しみを否定する。
- なぜだろうか？

#### -

- 数式は、少なくとも歴史的には、人間の言葉である。
- あるいは機械にとっても普遍的に有意義なものだろうか？
- 記号計算機能によって初めて（と言っても記号計算は sympy より古いが）、数式でプログラミングができるようになった。と考えてみよう。
- コンピュータは自動化を行い、それによる生産性の向上は人間に喜びをもたらす。しかしそれだけではない。
- sympy は、数式で対話する。与えた数式を sympy が変換した結果を、数式で返してくれる。
- input のみならず output が数式である。
- Python はインタプリタ言語であるから、そもそも、プログラム自体を動的にやり取りできる。eval 関数（exec 関数）がある。Python コード自体は sympy の数式オブジェクトではないが、それを求める必要もとりあえずないだろう。
- sympy を習得することは困難である。また習得する必要もない。しかし、たまに少し眺めるだけでも、sympy は魅力的である。
- 数式対話システム。
- 数式対話システムと、自然言語対話システムとは、さほど異ならないのではないだろうか。英語対話システムと日本語対話システムとの違い程度でないだろうか。

#### fbterm

- fbterm というプログラムがある。
- sudo apt-get install fbterm
- これを使うと、X Window System を使わずに、unicode で数式を表示できる。

#### business logic

- business logic という言葉がある。
- 胡散臭い言葉だとされることもある。科学的な概念ではないとされることもあるようである。
- 人々の集団などの大きな機能体を動作させている中心的な存在がビジネスロジックであると考えられる。
- システムは複雑になると計算しにくくなる。計算量が増加する。計算量を減少させるために、疎結合性を増加させることが行われる。
- ビジネスロジックを操作することが政治や経営であると考えられる。
- コンピュータによる自動化は、ビジネスロジックに浸透している。
- コンピュータを用いるのは、計算力を増加させて利益を得ようとするからである。実際、計算力は利益をもたらす。
- 政治にとっては、人々の価値観もまた前提ではない。ビジネスロジックの一部である。
- コンピュータは、足し算や引き算ができる。人間よりも遥かに高速にできるようになった。
- 人間にとって理想的なのは、自然言語で記述した論理をコンピュータが理解したり、対話的に口頭でコミュニケーションして情報をコンピュータに理解させることである。例えば、人間関係についての精神的な悩みを告げると、極めて的確で有効なアドバイスをくれるコンピュータが考えられる。また例えば、人間の心に浮かんだ哲学的な問いかけについて、真実へ近づくための助言を与えるコンピュータが考えられる。
- 現在のコンピュータは、まだそこまで進歩していない。
- しかし、sympy は数式を理解する。少なくとも少し理解する。
- 数式は、プログラミング言語ではない。そもそもはプログラミング言語ではないが、最近ではしばしばプログラミング言語である。例えば、Haskell における様々な関数の定義は、時として数学における記述と同一である。
- 例えば、ある企業の本社の一室に、大切に保管された数式があって、それによってその企業が動作しているという状態が考えられる。そして、その数式を書き換えることが、直ちにその企業の動作に反映されることが考えられる。すなわち、自動化によって、数式には言わば、血が流れる。血が流れている数式というのは、一つの理想である。コンピュータは、それに接近している。
- プログラミングとは、数式に血を流すことである。
- 数式に血が流れる時、論理が現実世界に肉体を現す。それは、神が地上に降り立つことに似ている。なぜなら、その論理は、人間が行う推論のように破綻していないからだ。
- 法律は、社会を動かすビジネスロジックである。しかしそれは、あまり効率的には見えない。
- ビジネスロジックの変化は、社会に対して最も大きな影響をもたらす。ゆえに、生産性を求めることはビジネスロジックについての議論にたどり着く。
- software-defined networking という言葉がある。現実の全てが、次第に software define されていく。現実の全てが、Python のインタラクティブなコマンドで変更されるようになっていく。人々にとって、妄想と現実の差がなくなっていく。
- しかしその全ては、hardware 的に implement されたビジネスロジックに依存している。それが機能停止すれば、停電のように、町は停止する。人々は、石器時代のように、自らの肉体の二本足で歩かざるをえなくなる。支援なくして相互に対話せざるをえなくなる。
- ビジネスロジックが、町を空に浮かべる。
- そのビジネスロジックの実装は、sympy による記号計算によって行われる。
- ビジネスロジックは動的でなければならない。ゆえに、記号はオブジェクトでなければならない。実行環境はインタプリタでなければならない。コンピュータに数式が表され、人間はその数式を操作する。
- ビジネスロジックの自動化は、重要なテーマである。そしてそれが記号計算システムによってなされる。
- かつて奴隷であった黒人が大統領になるように、かつて道具であったコンピュータが社会の王になる。
- といった大枠で考えることは有益かもしれない。

#### -

- 現実世界は連続的で、無限大の情報量を持っている。しかし、全ての連続的なものは離散的に近似的に扱える。（本当にそうかは知らない。）　グラフで全て表せる。
- 現実世界には、同時には真でないことがある。ゆえに、論理は現実について有効である。同時には真でないことは、or で表される。複数の条件を結合することは、and で表される。
- 例えば、2 次元空間における点は、x を 0 or 1、y を 2 or 3 として、x = 1 and y = 2 などと表される。
- 状態とは空間における位置のことである。位置とはグラフにおける頂点のことである。
- 型はフィールドらと、そのフィールドらの型で表される？
- Bool = True | False
- xor。A or B は A and B を含むから、xor のほうがいい気がする。しかし A xor B xor C は A and B and C を含むらしい。謎である。壁として作用するのは？ (A or B or C) and not ((A and B) or (B and C) or (C and A))。...面倒なので or で考える。
- or は軸に頂点が増えていく。and は軸が増えていく。
- SOP、POS。
- or は範囲が広がる。and で絞り込む。
- 探索空間は or で広がっている。and で解を見つけだす。

#### Python の凋落

- Python の人気がなくなってしまうことはあるだろうか？　Python の将来性はどうか？
- もし Python を使うなら、Python の人気がなくなってしまうことは好ましくない。
- Python にしろ Ruby にしろ、堅牢な OOP を組み立てるのは得意でないように見える。JavaScript に型制約を記述可能にしようとするような試みが見られるように、堅牢性への需要はある。関数型が未来であると言われ、事実そうであろうし Python の仕様もそれに近づきつつあるが、よくわからない。関数型には実績がないが OOP には実績がある。Python では、プライベートメンバは命名法で区別するとか、オブジェクトインスタンスは self として表すとか言われるが、その長所がわからない。\_\_private\_variable だとか \_\_init\_\_ だとか \_\_main\_\_ だとか、アンダースコアがユーザに露出すべきでない気がする。実装が見えているようで気味が悪い。OOP な制約を前提としない柔軟性が有意義なのだろう。しかし self と書くのが面倒くさい。あとコンパイル時にあまりエラーを見つけてくれない。
- C# の方が全体的な性質はずっと優れて見える。インタプリタ言語の人気というのは、変数の宣言が面倒くさいといった、非常に俗な欲求に支えられているところが大きいのではないだろうか？　もっと C# っぽいインタプリタ言語の方が近代的であるような気が、素人ながら、する。まあ、勘違いなのだろう。
- Python を美しいとは感じない。本質的に正しいとも、一貫性があるとも感じない。だから将来性について安心感を感じない。
- 例えば Java で、getExample() といったくどいメソッド名は、美しいと思う。
- ウェブブラウザでは JavaScript が使われる。JavaScript ばかりが使われる。あれも気味の悪い言語だと思う。基本的に、辞書の木である、という言語仕様は、シンプルで柔軟だと思う。しかし大きいものを作ろうとすると Java 的な OOP に近づける必要が生じ、そうすると一貫した方法論がない気がする。
- 理論上は、アセンブリで書けば何でもできるし、最も何でもできる。優れたプログラミング言語とは、大きなプログラムをバグなく作れる言語である。つまり、高い観点から制約を多く記述できる言語である。
- 商用の現場では、モデリングツールを使い、自動検査を多用してプログラミングすることが行われるのだろう。それはそれを含めて言語であるようなものである。例えば、あるコーディング規約がある時、望ましくは、それへの違反は自動的にコンパイルエラーなどとして検出されるべきである。
- 現在のプログラミングは、非常に多く、プログラマ達の常識に支えられているのだろう。そして多く、それに応じた程度の品質にとどまっているのだろう。
- プログラミングにおいて、部品 A が部品 B を通してのみ部品 C と通信していることは、どのように保証されているのだろうか？　そのような、言わばグラフを記述する機能を、言語自体が備えることは、あまり一般的ではないように見える。他のツールを使えばよい、ということなのかもしれないが、不思議に感じる。
- コーディング規約が人間に依存しているというのは、とても気味が悪い。自動化されていない部分は必ずバグだらけになるからである。
- Haskell は美しいと言われるし、美しいのだろうが、完成されて時間が経つ割に人気がない。純粋な関数型言語が圧倒的なシェアを得ることは今後も期待しにくいだろう。
- 宣言型よりも命令型の方がシンプルにわかりやすく書ける問題はある。ゆえに命令型を書くにあたって支障のある言語が汎用されることはない。
- Python が将来凋落する可能性はあるだろう。（例えば C 言語に比べてである。）　しかしそれを心配する必要はないだろう。現在において Python の代替はないからである。Python に先駆的？に導入される様々な近代的な技術は、より発展した次世代言語においても標準になる。ゆえに例えば、リストや辞書を気楽に使うということに慣れることは有意義である。命令型に基礎を置きつつ実装された遅延評価に慣れることも有意義だろう。
- C と C++ は成功した言語である。Java と C# も成功した言語と言っていいのだろう。それらのどれかしか使えなくなっても、世界はきっと破滅しない。Lisp、Perl、Python、Ruby、Haskell のどれかしか使えなくなったら、世界はきっと破滅するだろう。適当に言っている。Haskell しか使えない世界というのは、見てみたい気もする。もしかしたら理想的な世界なのかもしれない。
- 将来に人気の出るプログラミングパラダイムに対して、Python の言語仕様に組み込まれたパラダイムが時代遅れになり、Python は近代的な言語では明らかにないともし言われる時代が来たとしても、その欠陥がそう大きな欠陥ではなく、すでに Python に大きな実績があり、それなりに多くの人々がその生態系に留まるのであれば、Python は半永久的に大きな存在でありつづけるかもしれない。

#### -

- 業務分析という言葉がある。
- model-driven engineering というものがある。
- スペックの低いコンピュータに高度なソフトウェアを載せても動かない。組織の言葉は常にその人材に制約される。
- 自然言語には共通語としての広い用途がある。しかし実際に通信される抽象的な概念については、理解できるということは例外的な現象である。同一の専門の同一の水準の人同士にしか起こらない。
- 人材は資源の一部であり資源は多く前提である。前提は変化して環境と呼ばれる。与えられた資源を用いて今日生産した設備は、明日には明日にとっての資源になる。構造とは夢のようなものであって、絶対的ではない。
- 一面において、優れた成果を出す人々は優れた環境に恵まれている。また一面において、優れた人々はどうといって恵まれていない道具立てで人並み外れた成果を出している。リッチな道具を前提にすることは、一つの弱さである。ある専門についての本質的な理解は、対応できる道具についていくらかのスケーラビリティをもたらすと期待できる。
- 例えばある企業について、人材というよりもその業務ロジックに注目して見ることは、ある種、人々を物のように見なす傾向に繋がる。現実の個々の人の苦楽は複雑で、十分には抽象化できないからである。ゆえに、具体的な妥当性がなければ論理の残酷な自己満足に陥る。例えば経営は医療のようなものであって、助けるつもりで与えた刺激によって殺してしまうことも考えられる。国家の法律もそうだろう。社会についてその中枢たるアルゴリズムを考えることは、社会主義、設計主義、計画主義、全体主義的な体制への傾きを持つ。
- しかし、実際のアルゴリズムは人々の能力の上に浮かぶ存在である。良いものが伝承されない場合もある。現実的な有効性のない空論には価値がない。
- 一方で、コンピュータ技術の発展が人々のその限界を変更しているとも考えられる。テキストにすれば本何百冊にも及ぶ情報量が、一般の個々人のもとに蓄えられ、全く正確に遠隔な地点と通信されている。将来が大きな変化を伴うものであるなら、それを少しでもより良くすることは意義深いことであると考えられる。
- Unified Modeling Language (UML) というものがある。（将来の）AI は UML で会話すると考えられる。これは全く安易な考えだが、自然言語より高度な抽象をもって通信されることを類推する意味では使えるだろう。
- 類推は、計算量を減少させつつ、しばしば実用上十分に正確な解をもたらす。より正確な論理と言えども、抽象化の時点について同じことが言えるのだから、あまり威張れない。現実は計算できない。
- コンピュータの上層を学ぶことは、AI の言葉を学ぶ面白みがある。
- 実際の UML は、一般的な共通の記述方法がなく、実装と同期させることにも限界があるため、理想的に汎用することはできない。数式は血が通ってこそ価値があると見ることができ、その意味で、プログラミング言語や、Python SymPy モジュールが最も上層の言語である。
- 実際の sympy は、そのような方向性の可能性を潜在させるものではあってもそういうものではないので、理想的に汎用することはできない。
- 抽象的な構造を記述してそれによって現実を自動化するという考え方は魅力的である。
- 一般的なプログラミング言語は、パフォーマンスを優先するためにそこまで抽象的な表現を用いていない。
- Lisp では、プログラム自身を操作できると聞く。そのレイヤーを少し持ち上げたものを用いると便利かもしれない。
- メモリにロードされたプログラムは、アセンブリとして表現されていると考えることができる。手続き型、命令型な表現である。命令型には宣言型が対置されると言われる。宣言型の記述が、動的に変更可能であってもいい。欲しいのは、宣言型のアセンブリが欲しいということかもしれない。
- Lisp は優れた人々に評価が高いらしいが知らない。歴史があるのに、Python などに比べて人気がないようである。実用性は低いのかもしれない。
- Python ファイルを関数とするようなシステムの組み上げ方を初歩的にでも学んでおくことは有意義である気がする。速度がいるところは C++ などを使う。

#### IPython

- 単なる python というコマンドでもインタラクティブに python を用いることはできるが、ipython というコマンドで使える IPython というものの方がずっと便利であるようだ。メンバのサジェストなどの支援機能がある。
- ipython qtconsole というものがある。ここで sympy を使うと、Latex で表示され美しい。
- ipython qtconsole を念頭に、ipython を使うことに習熟すると良さそうである。なるべく ipython に没頭し、なるべく ipython の中で作業を行おうとすることが有意義そうである。
- しかし、直ちに bash を代替できるほどの機能が充実はないようである。
- よって、ipython を使うならば、実際には、普通のシェルと行き来しながら使うことになるだろう。

#### -

- 対話的なプログラミングと対話的でないそれとはどのような関係にあるのだろうか？
- Unix におけるコマンドとシェルスクリプトの関係は、Python におけるパッケージとインタラクティブ環境の関係に似ている。ここで Python （等）が優れているのは、コマンドもまた Python で実装可能であることによって、動的環境と静的環境がより連続的であることである。
- インタラクティブ環境は、一つの関数であり、一つのプログラムである。決まった出力のみ生じるのではなく、与えた入力によって出力が変わる。非対話的にできることは、原理的には対話的にも行える。
- 対話的に行う作業の中で、いくらか繰り返され、自動化可能であるものがある。それはモジュールにする。あるいはさらに、他の言語などによりより高速な実装などにする。
- モジュールはやがて陳腐化する。プログラムにはライフサイクルがある。
- ユーザと対話したい場合には、インタラクティブ環境に対してインタフェースを露出することが、汎用性のある方法である。独立したアプリケーションとして閉じた GUI を持つことなどは、柔軟性に欠ける。モジュールは Python オブジェクトであり、Python オブジェクトとして操作可能であって、露出されるインタフェースは、そこを通してアクセスされる。
- 動的に操作可能なオブジェクトとして、汎用なインタラクティブ環境の上に属することが有意義である。
- モジュールはメンバを持つオブジェクトである。それぞれのモジュールのメンバは、そのモジュールの中においてグローバルな名前を持つ。このスタイルは行儀の悪いものであるかもしれない。モジュールに状態を持たせるとシングルトンになってしまうかもしれない。別途普通にオブジェクトを定義した方がいいのだろう。クラス名を C として何にせよコンストラクタで実行することが良いかもしれない。状態を持たない場合は静的関数 f などとする。
- こういった議論は、プログラミング以前であって、プログラミングのためのプラットフォームを選択しているにすぎない。

#### -

- （Python を用いた）ラピッドプロトタイピングということが言われる。
- まず Python で組み、C++ などに変化させていく。
- しかし一面では、Python のみで実装されていることが理想的である。その方が動的に対話でき、つまりオブジェクトと会話できるからである。
- 動作中のプログラムモジュールと、ユーザがコミュニケーションできることが望ましい。
- プログラムの構成は、実行しながら変更可能であることが望ましい。

#### -

- bash などではパイプやリダイレクトという機能が便利である。
- ipython においてこれを簡単に使う方法はないようである（←誤り）。
- 言語仕様をなるべく活かした方がいい。リッチなことをすると面倒になる。
- 状態を持つことについて否定的な考え方もある。関数型パラダイムにはその傾向がある。
- Java 的なオブジェクト指向プログラミングでは多く、アクセスパーミッションと型制約とが分離されていない。アクセスパーミッションと型制約は何にせよ不可欠だろう。
- データには、データベースは無視して考えると、ファイルとメモリの区別がある。これは理想的ではないかもしれない。ファイルからメモリに翻訳することを load、その逆を store と呼べる。あるいは read と write。
- ロードされると、共通の空間で動的な存在になる。
- イミュータブルなオブジェクトは、状態を持たないと言っていいのだろうか？
- 型制約を記述する方法は普通、十分に用意されていないが、それはパフォーマンスのためだろう。例えば変数 a と b が a < b を満たすことは書きにくい。命令型で、setA() と setB() の中で分岐させ例外を投げることになる。
- 例えばテキストファイルにグラフの情報が書かれていて、そのグラフを ipython 上に可視化する機能を実装したい場合を考える。関数やメソッドにデータを渡すには、ストリームオブジェクト、ファイルパス、文字列オブジェクト、といったものが考えられる。遅延評価やバッファの意味でストリームオブジェクトが最も好ましく、それら機能がないものの文字列オブジェクトが最も簡単な気がする。
- リダイレクトで渡したいところだが、ipython 上ではできないようである（←誤り）。
- 例えば、sys.stdin は共有されていそうなので、コロコロ変えるべきものではない気がする。
- 標準入力で対話すると、python の変数の展開などに支障が出て好ましくない。
- 対話は ipython で行うことを考える。
- モジュールへの入力はクラスのコンストラクタの引数として与える。出力は、そのオブジェクトのメソッドを呼び出すか、フィールドにアクセスする。
- オブジェクトの状態へのアクセスは、とりあえずフィールドとして実装しておいても、後から property という機能を使ってアクセサを設定できるようである。@property def x(self): return self.\_x とか @x.setter def x(self, value): self.\_x = value とするようである。書くのが面倒くさそうである。
- 出力はまずオブジェクトの中に展開されることになる。連想配列としてである。このことは、名前を散らかりにくくするかもしれない。
- 遅延評価の考え方で行くと、データは入力の時にではなく出力の時に計算されることになる。入力というのは、例えば f(x) について f(0) などと、式を組み立てただけである。
- イミュータブルではないオブジェクトについて、変数を変更した時には効果が反映されず、eval() メソッドなどで反映されるということが考えられるが、面倒である。

#### -

- 上で、IPython からパイプやリダイレクトが使えないということを書いたが、誤りであって、普通に使えるようである。コマンドを ! で開始すれば、（bash など）普通のシェルで行える操作は行えるようである。
- ほとんどの作業について IPython で bash を代替することは、可能ぽい。
- テキストで入出力したいということと、Python オブジェクトを入出力したいということは分けて考えることができる。
- IPython 上では例えば !echo 10 とすると 10 が出力される。しかし、スクリプトファイルに !echo 10 と直書きして magic function である run などでそれを実行してもエラーになる。Python においてプログラムからプログラムの利用は import などを用いて行われると思われるが、IPython 上でもその様式に従うことを基本に考えたほうが良さそうである。
- Python オブジェクトをやり取りするにあたっては、Python の関数への引数を入力とし、返り値を出力とすることがわかりやすい。
- OOP として見るならば、モジュールの利用は常にそのインスタンスについて実施されるべきであると考えることができる。であれば、モジュールはクラスとして見たい。
- Ruby という言語があるが知らない。オブジェクト指向という意味では Python より徹底されていて美しいとも言われる。
- 理想的には、既存の稼働している Python プログラムに対して IPython というインタフェースから（複数のユーザが）アクセスすることを考えたい。
- 従来、ターミナルエミュレータ上で emacs を使っていたが、ipython qtconsole ではインラインでテキストエディタを使うことはできないようなので、従来の方法を同等に行うことはできない。Gui で使うなら emacs はさほど良いものではない気がする。
- 従来、ターミナルエミュレータとウェブブラウザを画面上に開いていたが、ipython qtconsole が追加されてすでに鬱陶しい上に、テキストエディタも別途ウィンドウを持つとなると、面倒である。というのも、Alt+Tab でアプリケーションを切り替えているのだが、手間な上によく失敗する。それぞれのアプリケーションに移動するためのキーボードショートカットを設定するのが合理的だと思われるが、特殊化は最小限にしたい。
- 私が（Windows ではなく）Ubuntu を使う最大の理由は、美しく思う Ubuntu のフォントを見て喜びを得るためである。同様に、Qt Console を使う最大の理由は、latex を見て喜びを得るためである。という雑な考え方もできる。機能という意味で今、優先して探求したいのは、SymPy を機能的に使うということである。
- （Qt Console で）インラインで matplotlib のプロットを見ることができるのは便利である。平面や立体の表示は時として便利だろう。先日は networkx を使って、グラフを操作しまた視覚化したが、機能的であった。
- 優れたプラットフォームがシェアを得るということが言えるが、シェアを得たプラットフォームが優れたプラットフォームであるとも言える。私には、Python と他のプログラミング言語の優劣はわからないが、現実的な Python のいわゆる生態系が（例えば Haskell に比べて）大きいならば、そのことは十分に重視しなければならない。
- 枯れていて永遠であるという意味では、Unix + C の方がずっと実績がある。しかし、安定している範囲において、なるべくリッチなものも利用したい。しかし、道義的な意味でも打算的な意味でも、OSS (open source softwares) を重視したい。最も先進的なテクノロジは、プロプライエタリな商用製品として実現しているに決まっているだろうし、そのほとんどを、私は人生において見る機会もないだろう。しかし、フリーな世界がすでに実現したことは多い。Ubuntu は Windows のように簡単で安定しているし、Python で記号計算ライブラリ SymPy を使うことは、おそらく一面で Mathematica や Matlab を凌駕している。なお Mathematica や Matlab が何であるかはよく知らない。
- 私は数学ができない。そして、そのことに全く満足しているというよりは少し残念に思っており、可能なら残りの人生の間に少しでも身につけたいと思っている。
- 四則演算を人力で行うことはアセンブリを書くようなものである。プログラムを勉強するのにアセンブリから勉強すべきであるという意見は今日はないし、C から勉強せよということも今や間違いになりつつあるだろう。幼いうちから全ての子供達が Qt Console で SymPy を使うことが、知的発展のために合理的であると思われる。私の適当な認識では、SymPy の発展は、Mathematica が（初めて）無料になったということであり、それは相対的に貧しい地域の人々の教育環境について大きな変化であると思われる。
- しかし、数学がある程度できる人達にとっては、記号計算ライブラリで何ができるわけもなく、その数学教育についての有用性も将来にわたってゼロなのかもしれない。私自身が数学がある程度でき、SymPy をある程度知っているのでなければ、正しい判断もできないし、意味ある意見も言えないが、私は数学ができず SymPy を知らない。
- 私は、Haskell が何であるか知らずに Haskell に惹かれていた。同様に、SymPy が何であるか知らずに SymPy に惹かれている。それで何がしたいというイメージが非常に漠然としている。的外れな夢を見ている。
- 私の理想的なイメージは、現実の全てが software define されており、企業や行政のビジネスロジックが数学的に（数式で）実装されていることである。
- Haskell は、宣言的に記述してくれるが、直ちに latex で表示してくれない。また、式が動的に扱えない(?)。理想的には、数式がユーザインタフェースとして使えるべきであると考えられ、その意味で Haskell は未だ理想的ではない。あるいは、言語として理想的ではあっても、生態系としては理想的ではなく、一面で Python に劣っている。あるいや役割が違う。
- 可視化は重要である。可視化とは抽象化である。抽象化とは、情報量を減らすことで計算可能にする方法である。人間（の脳）は計算機である。
- ある種の言葉は分かり合いやすく、ある種の言葉はそうではない。コンピュータによってある抽象を実装することは、その抽象を現実的に証明することであり、分かり合える言葉の範囲が広がることである。あるいは例えば、私達がグーグルでキーワードを検索する時、その検索に用いられているアルゴリズムを知らず、仮に知らされても理解できないが、それがコンピュータに実装されたことで、その利用を通して、そのアルゴリズムの正しさを受け入れているのだと考えることができる。
- グーグルの検索アルゴリズムについて例えば、ローレベルな実装は C （やアセンブリ）で行われ、ハイレベルなドキュメンテーションは数学的な論文として行われていると考えられる。その整合性は、精度を努力する意味で人間が行う。ただし、整合性の実現は自動化されることが理想的である。
- そのように、全てのビジネスロジックはハイレベルには数学の論文として実装されているのだと考えることができる。あるいは、よりハイレベルあるいはより広義には、数学的ではない論文として実装されている。数学の論文には、数学の証明が書かれている。また、数学的ではない論文には、数学的ではない証明が書かれている。
- 数学的な証明は論理的に行われるが、数学的ではない証明は類推的に行ってもいい。正しさは文脈によって担保する。
- 多くの人が、（可能なら論理的な）文章によって考えを表明し合い、多くの人がそれを読み合うことが、人々が人々の計算力を互いに活かすために有意義であると考えられる。人間が思考を文書化するということは、具体的な実装よりもハイレベルな意味を持っている。
- 一方で、多くの人は、Python の科学計算機能や記号計算機能を、言わば電卓として使っている。電卓として使っているというのは言わば、欲しいのは結果であり、そこで用いられたアルゴリズムは刹那的に破棄されるということである。あるいは（継続的に）状態を持たないということである。機械のみによる自動化ではなく、機械と人が融合したシステムがそこにある。
- 例えば企業にとって重要なのは、従業員に対して優れた電卓を提供することである。そうして、ワークフローを最適化し生産性を増加する。
- また逆に、人間を一種の電卓として見ることもできる。ただし、人間は道具ではないということも、雑な表現ではあるが欠かせない事実である。
- 電卓という意味で、Python + IPython Qt Console + SymPy は、現在において（多くの用途にとって）最も良いものだろう。
- 理想的なのは、「人間＋機械」のシステムと、「機械のみ」のシステムとをシームレスに連続させることである。それは、SymPy が Python によって実装されていることで、ある意味ではすでに実現されている。
- 現在では、インタプリタ言語、特に Python が、様々な専門機能について、最も広く接続する、バス回路のような立場を得ている。例えば、ある記号計算機能や科学計算機能が独自の言語や実行プログラムによって実装される場合、それは仮に拡張可能ではあっても、外部とシームレスではなくなる。Python で実装したとしても Python の外に対してはシームレスではないのだが、Python はコンピュータシステムのすでにハブであるから、意味が異なる。
- Python は言わば「何でも言語」である。シームレスな自動化基盤である。
- 端末には、表示機能と、操作機能と、電卓機能がある。従って、システムには、表示 API と操作 API と電卓 API とがある。入出力とユーティリティ機能である。
- 正直、プログラミング言語を学ぶのはかったるいから、Python を勉強するならなるべく Python 以外勉強したくない。C++ の STL の使い方は忘れたい（覚えていないが）。Python に依存するなら、Python にだけ依存し、なるべく統合したい。C で実装されている機能についてすら、パフォーマンスが不要になり次第、全て Python に翻訳したい。コンピュータの OS も Python で実装されていてほしい。
- Python は集合知である。集合知は結局、勝利する。極めて雑然としている中から結局、最も整理されたものが現れる。人々はプロプライエタリを愛さない。人々はいつか、支配を拒絶する。人々が支配を拒絶した時、支配を強制しつづけることはできない。Python は言語ではなく生態系である。
- 時代は変わってしまう時には変わってしまうので、大きな生態系でも速やかに敗れ去ることはある。多くは予測できない。
- プログラムは、データか関数かと言えば関数だろう。重要性はないかもしれない。それぞれの機能が何言語で実装されているかは、重要ではないかもしれない。
- データは、テキストや CSV や JSON や XML が扱いやすい。大きなものについてはデータベースが使われる。
- Python ではシリアライズ機能があるが、ほとんど human readable ではないらしい。
- SymPy は再帰が書けないので実際にはプログラミングができない(?)。
- OOP ではデータがオブジェクトに格納されプログラムでインタフェースが記述される。
- OOP は成功したパラダイムである。また、OOP について、メッセージを重視する考え方もある。
- プログラミングの際、object0. となどと入力して、それに属するメソッドが表示されるのは便利である。f a b c などと入力した際に、a、b、c の型に応じて f の選択を支援してくれれば理想的でその方がいいのかもしれないが、とりあえず一般的でない。前者の方法は名前空間との関係がわかりやすい。名前空間を汚さないことがやりやすい。
- （従来的な OOP に比べて）DB と純粋関数で記述するのが（ハイレベルであり）将来的であるというようなことが言われる。関数はデータの一種である。
- あるクラスのメソッドというのは、そのクラスという集合の元について定義された関数だということである。クラスの中に関数を定義するのは、関数の定義域を制約する方法である。
- メッセージというのは記号の列である。例えば二進数の列である。解釈には（共有される）プロトコルが必要である。
- オブジェクトはグラフをなす。ワークフローはグラフをなす。数式はグラフをなす。古典的な、例えば C 言語の普通のソースコードでは、そのままでは call graph がイメージしにくい。ユーザにグラフを可視化していくことが重要であると思われる。可視化はインタラクティブでなければならない。グラフ指向パラダイム。
- ただし基本的なグラフそのものは、制約が弱くどうといって意味を表さない。
- entity-relationship model というものがある。
- ユーザインタフェースなどについて稀に簡単化という言葉が使われる。easification。easification は、相手の言葉に翻訳することである。相手に類推しやすくすることである。言わば類推性を増加することである。
