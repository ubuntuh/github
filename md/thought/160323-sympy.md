# sympy

### 2016-03-23 Wed

- プログラミング言語 Python のライブラリで sympy というものがある。記号計算機能を提供する。
- 用いるためには、基本的な数学の知識が必要になる。ゆえに私が使うことは難しい。
- しかしそのコンセプトには、興味深いところがある。

#### -

- sympy で面白く思った点の一つは、CUI で（human readable に）数式が表示できることである。
- 数式と言えば、最も美しいのは latex などによる表示である。latex を簡単に使うには、web サービスなどとして MathJax を用いるのが便利である。
- IPython Notebook というものがあると聞いて、以前、少しだけ触った。興味深かったが、複雑であってシンプルでなく、汎用的に依存しつづけたいとは思わなかった。IPython Notebook で、sympy を使い latex 的に美しい数式を表示することを知った。
- 改めて思うに、IPython Notebook 上でなくても sympy は使える。terminal で python インタプリタを起動して sympy を使うと、unicode を用いて数式を表示してくれる。
- latex ほど美しくないが、意外と問題ないのではないだろうか？　CUI で動くというのは、私にとっては魅力的であった。

#### Mathematica

- Mathematica という記号計算プログラムがあって、科学者などに広く用いられているらしい。高額で高機能であるらしい。私は使ったことがない。
- Photoshop と Gimp のようなものだろうか。
- Mathematica は、1988 年に Stephen Wolfram が作った。SymPy は、2007 年に Ondrej Certik が作った。
- Mathematica では、Wolfram Language という独自の言語を使うらしい。それは短所と見ることができる。
- Mathematica は、CUI での unicode による数式の表示をサポートしているか不明である。
- sympy は Mathematica にくらべ、Python で実装されておりパフォーマンスに劣る。
- sympy は、基本的には、Mathematica の機能を追いかけているのだと見ることができる。
- しかし、ライセンスや言語などについて、多くの長所も持っている。

#### 関数電卓

- sympy は、関数電卓に似ている。
- 関数電卓は、Mathematica に似ている。

#### Python

- Python は、成功した言語である。
- C++、Python、Java、JavaScript が、成功した言語だと考えることができる。C は C++ に、C# は Java に数えてみる。native 言語、インタプリタ言語、仮想マシン言語、ウェブブラウザ言語である。
- Perl は Python に代替された、Ruby は Python に負けた、と雑に考えることができる。一方で、上の 4 つには、少なくとも結果的に住み分けがあるようである。
- Lisp と Haskell は、あまり使われていないと考える。

#### Haskell

- Haskell を少し触ったが、教養として興味深いものであった。しかしパフォーマンスの見通しが悪い。
- Haskell は、プログラミング言語が進歩すれはそれはいわゆる数学に近づいていくのだということを示しているとも思えた。非破壊的な変数、副作用のない関数。
- しかし、sympy は Python において生まれ、Haskell において生まれたのではなかった。Haskell においては、同様のものはないらしい。
- sympy の価値を仮に大きく見た場合、それは Python に対する Haskell の敗北を示しているのではないか。
- Python は充実したライブラリを持ち、高度な処理に広く実用されている。すでに実績がある。
- Python で単純な OOP を書くのは、何も面白くないと思う。大きなものを実装するためには、Java のほうが美しい言語なのではないかと思う。私は、Python の言語仕様に惹かれなかった。
- しかし、sympy の存在は、私が Python を好む理由になるのではないか？

#### 哲学

- 数学を知らない私にとっては、Mathematica や sympy は純粋に魔法である。そして、利用できないし、利用する必要性もない。
- また、魔法に見えるから限界が見えず偉大に見えるのであって、実際には、現在のコンピュータで行える記号計算の有効範囲には強い限界があるだろう。
- しかし、そのような実用性の議論を越えて、私にとっての sympy は、哲学的な意味を持っているような気がする。世界観を更新するところがある気がする。
- Mathematica もろくに知らなかった私にとっては、sympy のような機能というのは、コンピュータにできることを越えているようにも印象される。
- オープンソースな Python ライブラリであるということは、どこにでも組み込めることを意味している。

#### 数式

- 数式は、歴史的には人間のためのものであったと、雑に考えることができる。
- プログラムを実装するためには、数式からプログラミング言語へと翻訳する必要があった。また、プログラムを読む際にはプログラミング言語から数式への翻訳が必要であったと言えるが、それは一般に困難であった。
- 記号計算プログラムは、その階層を破壊する。数式によるプログラミングを可能にすることで、翻訳を不要にする。それは、歴史的には人間にのみ可能であった計算領域に、機械が侵入してくるのだとも見られる。
- 人間が行う推論の中で、数式は最も端的に論理的な部分であり、論理的であるという意味でそれ以上の部分はない。
- ゆえに数式がコンピュータにも操作可能になるということは、コンピュータが人間とある意味同等な知性にまで育ったようなものである。人間にできてまだコンピュータにできないことは膨大にあるが、逆もそうであるという意味で同等である。
- コンピュータが進歩するほど、コンピュータを見ることで、人間は宗教的な主観を離れ、鏡を見るかのように、正しく自分を見られるようになる。
- 大げさに言えば、人間が sympy を使っているのか、sympy が人間を使っているのか、不明である。
- 数式によってプログラミングすることで、人間による計算とコンピュータによる計算とが重なる。それは、人間の脳とコンピュータが融合しているのだとも考えられる。それは、人間にとっては、自らが拡張されているのだとも考えられる。

#### 感情

- 私達の持つ感情とは、そもそも何なのだろうか？、と考えさせるところが、記号計算機能にはある。
- 理知的に見れば、世界は全く必然である。なすべきことをなす時に、あえて感情を伴わせる必要があるだろうか？　高級な仕事ほど私心を殺させるところがあると見ることもできる。
- 人間には、先天的な欲求がある。それによって苦楽があり、利益や価値がある。死を恐れ、名誉を求める。
- 先天的な欲求を満足させるために尽くすことが、有意義な人生だろうか？
- 人間の知性は、部分最適のための闘争に狂った喜びを見ることに終わる。
- 一方で、コンピュータの行う推論は、論理的な誤りを起こさない。超越的なほどに正直である。
- コンピュータは人間の脳にとって鏡であり、真理を見せることによって心の苦しみを否定する。
- なぜだろうか？

#### -

- 数式は、少なくとも歴史的には、人間の言葉である。
- あるいは機械にとっても普遍的に有意義なものだろうか？
- 記号計算機能によって初めて（と言っても記号計算は sympy より古いが）、数式でプログラミングができるようになった。と考えてみよう。
- コンピュータは自動化を行い、それによる生産性の向上は人間に喜びをもたらす。しかしそれだけではない。
- sympy は、数式で対話する。与えた数式を sympy が変換した結果を、数式で返してくれる。
- input のみならず output が数式である。
- Python はインタプリタ言語であるから、そもそも、プログラム自体を動的にやり取りできる。eval 関数（exec 関数）がある。Python コード自体は sympy の数式オブジェクトではないが、それを求める必要もとりあえずないだろう。
- sympy を習得することは困難である。また習得する必要もない。しかし、たまに少し眺めるだけでも、sympy は魅力的である。
- 数式対話システム。
- 数式対話システムと、自然言語対話システムとは、さほど異ならないのではないだろうか。英語対話システムと日本語対話システムとの違い程度でないだろうか。

#### fbterm

- fbterm というプログラムがある。
- sudo apt-get install fbterm
- これを使うと、X Window System を使わずに、unicode で数式を表示できる。

#### business logic

- business logic という言葉がある。
- 胡散臭い言葉だとされることもある。科学的な概念ではないとされることもあるようである。
- 人々の集団などの大きな機能体を動作させている中心的な存在がビジネスロジックであると考えられる。
- システムは複雑になると計算しにくくなる。計算量が増加する。計算量を減少させるために、疎結合性を増加させることが行われる。
- ビジネスロジックを操作することが政治や経営であると考えられる。
- コンピュータによる自動化は、ビジネスロジックに浸透している。
- コンピュータを用いるのは、計算力を増加させて利益を得ようとするからである。実際、計算力は利益をもたらす。
- 政治にとっては、人々の価値観もまた前提ではない。ビジネスロジックの一部である。
- コンピュータは、足し算や引き算ができる。人間よりも遥かに高速にできるようになった。
- 人間にとって理想的なのは、自然言語で記述した論理をコンピュータが理解したり、対話的に口頭でコミュニケーションして情報をコンピュータに理解させることである。例えば、人間関係についての精神的な悩みを告げると、極めて的確で有効なアドバイスをくれるコンピュータが考えられる。また例えば、人間の心に浮かんだ哲学的な問いかけについて、真実へ近づくための助言を与えるコンピュータが考えられる。
- 現在のコンピュータは、まだそこまで進歩していない。
- しかし、sympy は数式を理解する。少なくとも少し理解する。
- 数式は、プログラミング言語ではない。そもそもはプログラミング言語ではないが、最近ではしばしばプログラミング言語である。例えば、Haskell における様々な関数の定義は、時として数学における記述と同一である。
- 例えば、ある企業の本社の一室に、大切に保管された数式があって、それによってその企業が動作しているという状態が考えられる。そして、その数式を書き換えることが、直ちにその企業の動作に反映されることが考えられる。すなわち、自動化によって、数式には言わば、血が流れる。血が流れている数式というのは、一つの理想である。コンピュータは、それに接近している。
- プログラミングとは、数式に血を流すことである。
- 数式に血が流れる時、論理が現実世界に肉体を現す。それは、神が地上に降り立つことに似ている。なぜなら、その論理は、人間が行う推論のように破綻していないからだ。
- 法律は、社会を動かすビジネスロジックである。しかしそれは、あまり効率的には見えない。
- ビジネスロジックの変化は、社会に対して最も大きな影響をもたらす。ゆえに、生産性を求めることはビジネスロジックについての議論にたどり着く。
- software-defined networking という言葉がある。現実の全てが、次第に software define されていく。現実の全てが、Python のインタラクティブなコマンドで変更されるようになっていく。人々にとって、妄想と現実の差がなくなっていく。
- しかしその全ては、hardware 的に implement されたビジネスロジックに依存している。それが機能停止すれば、停電のように、町は停止する。人々は、石器時代のように、自らの肉体の二本足で歩かざるをえなくなる。支援なくして相互に対話せざるをえなくなる。
- ビジネスロジックが、町を空に浮かべる。
- そのビジネスロジックの実装は、sympy による記号計算によって行われる。
- ビジネスロジックは動的でなければならない。ゆえに、記号はオブジェクトでなければならない。実行環境はインタプリタでなければならない。コンピュータに数式が表され、人間はその数式を操作する。
- ビジネスロジックの自動化は、重要なテーマである。そしてそれが記号計算システムによってなされる。
- かつて奴隷であった黒人が大統領になるように、かつて道具であったコンピュータが社会の王になる。
- といった大枠で考えることは有益かもしれない。

#### -

- 現実世界は連続的で、無限大の情報量を持っている。しかし、全ての連続的なものは離散的に近似的に扱える。（本当にそうかは知らない。）　グラフで全て表せる。
- 現実世界には、同時には真でないことがある。ゆえに、論理は現実について有効である。同時には真でないことは、or で表される。複数の条件を結合することは、and で表される。
- 例えば、2 次元空間における点は、x を 0 or 1、y を 2 or 3 として、x = 1 and y = 2 などと表される。
- 状態とは空間における位置のことである。位置とはグラフにおける頂点のことである。
- 型はフィールドらと、そのフィールドらの型で表される？
- Bool = True | False
- xor。A or B は A and B を含むから、xor のほうがいい気がする。しかし A xor B xor C は A and B and C を含むらしい。謎である。壁として作用するのは？ (A or B or C) and not ((A and B) or (B and C) or (C and A))。...面倒なので or で考える。
- or は軸に頂点が増えていく。and は軸が増えていく。
- SOP、POS。
- or は範囲が広がる。and で絞り込む。
- 探索空間は or で広がっている。and で解を見つけだす。

#### Python の凋落

- Python の人気がなくなってしまうことはあるだろうか？　Python の将来性はどうか？
- もし Python を使うなら、Python の人気がなくなってしまうことは好ましくない。
- Python にしろ Ruby にしろ、堅牢な OOP を組み立てるのは得意でないように見える。JavaScript に型制約を記述可能にしようとするような試みが見られるように、堅牢性への需要はある。関数型が未来であると言われ、事実そうであろうし Python の仕様もそれに近づきつつあるが、よくわからない。関数型には実績がないが OOP には実績がある。Python では、プライベートメンバは命名法で区別するとか、オブジェクトインスタンスは self として表すとか言われるが、その長所がわからない。\_\_private\_variable だとか \_\_init\_\_ だとか \_\_main\_\_ だとか、アンダースコアがユーザに露出すべきでない気がする。実装が見えているようで気味が悪い。OOP な制約を前提としない柔軟性が有意義なのだろう。しかし self と書くのが面倒くさい。あとコンパイル時にあまりエラーを見つけてくれない。
- C# の方が全体的な性質はずっと優れて見える。インタプリタ言語の人気というのは、変数の宣言が面倒くさいといった、非常に俗な欲求に支えられているところが大きいのではないだろうか？　もっと C# っぽいインタプリタ言語の方が近代的であるような気が、素人ながら、する。まあ、勘違いなのだろう。
- Python を美しいとは感じない。本質的に正しいとも、一貫性があるとも感じない。だから将来性について安心感を感じない。
- 例えば Java で、getExample() といったくどいメソッド名は、美しいと思う。
- ウェブブラウザでは JavaScript が使われる。JavaScript ばかりが使われる。あれも気味の悪い言語だと思う。基本的に、辞書の木である、という言語仕様は、シンプルで柔軟だと思う。しかし大きいものを作ろうとすると Java 的な OOP に近づける必要が生じ、そうすると一貫した方法論がない気がする。
- 理論上は、アセンブリで書けば何でもできるし、最も何でもできる。優れたプログラミング言語とは、大きなプログラムをバグなく作れる言語である。つまり、高い観点から制約を多く記述できる言語である。
- 商用の現場では、モデリングツールを使い、自動検査を多用してプログラミングすることが行われるのだろう。それはそれを含めて言語であるようなものである。例えば、あるコーディング規約がある時、望ましくは、それへの違反は自動的にコンパイルエラーなどとして検出されるべきである。
- 現在のプログラミングは、非常に多く、プログラマ達の常識に支えられているのだろう。そして多く、それに応じた程度の品質にとどまっているのだろう。
- プログラミングにおいて、部品 A が部品 B を通してのみ部品 C と通信していることは、どのように保証されているのだろうか？　そのような、言わばグラフを記述する機能を、言語自体が備えることは、あまり一般的ではないように見える。他のツールを使えばよい、ということなのかもしれないが、不思議に感じる。
- コーディング規約が人間に依存しているというのは、とても気味が悪い。自動化されていない部分は必ずバグだらけになるからである。
- Haskell は美しいと言われるし、美しいのだろうが、完成されて時間が経つ割に人気がない。純粋な関数型言語が圧倒的なシェアを得ることは今後も期待しにくいだろう。
- 宣言型よりも命令型の方がシンプルにわかりやすく書ける問題はある。ゆえに命令型を書くにあたって支障のある言語が汎用されることはない。
- Python が将来凋落する可能性はあるだろう。（例えば C 言語に比べてである。）　しかしそれを心配する必要はないだろう。現在において Python の代替はないからである。Python に先駆的？に導入される様々な近代的な技術は、より発展した次世代言語においても標準になる。ゆえに例えば、リストや辞書を気楽に使うということに慣れることは有意義である。命令型に基礎を置きつつ実装された遅延評価に慣れることも有意義だろう。
- C と C++ は成功した言語である。Java と C# も成功した言語と言っていいのだろう。それらのどれかしか使えなくなっても、世界はきっと破滅しない。Lisp、Perl、Python、Ruby、Haskell のどれかしか使えなくなったら、世界はきっと破滅するだろう。適当に言っている。Haskell しか使えない世界というのは、見てみたい気もする。もしかしたら理想的な世界なのかもしれない。

#### -

- 業務分析という言葉がある。
- model-driven engineering というものがある。
- スペックの低いコンピュータに高度なソフトウェアを載せても動かない。組織の言葉は常にその人材に制約される。
- 自然言語には共通語としての広い用途がある。しかし実際に通信される抽象的な概念については、理解できるということは例外的な現象である。同一の専門の同一の水準の人同士にしか起こらない。
- 人材は資源の一部であり資源は多く前提である。前提は変化して環境と呼ばれる。与えられた資源を用いて今日生産した設備は、明日には明日にとっての資源になる。構造とは夢のようなものであって、絶対的ではない。
- 一面において、優れた成果を出す人々は優れた環境に恵まれている。また一面において、優れた人々はどうといって恵まれていない道具立てで人並み外れた成果を出している。リッチな道具を前提にすることは、一つの弱さである。ある専門についての本質的な理解は、対応できる道具についていくらかのスケーラビリティをもたらすと期待できる。
- 例えばある企業について、人材というよりもその業務ロジックに注目して見ることは、ある種、人々を物のように見なす傾向に繋がる。現実の個々の人の苦楽は複雑で、十分には抽象化できないからである。ゆえに、具体的な妥当性がなければ論理の残酷な自己満足に陥る。例えば経営は医療のようなものであって、助けるつもりで与えた刺激によって殺してしまうことも考えられる。国家の法律もそうだろう。社会についてその中枢たるアルゴリズムを考えることは、社会主義、設計主義、計画主義、全体主義的な体制への傾きを持つ。
- しかし、実際のアルゴリズムは人々の能力の上に浮かぶ存在である。良いものが伝承されない場合もある。現実的な有効性のない空論には価値がない。
- 一方で、コンピュータ技術の発展が人々のその限界を変更しているとも考えられる。テキストにすれば本何百冊にも及ぶ情報量が、一般の個々人のもとに蓄えられ、全く正確に遠隔な地点と通信されている。将来が大きな変化を伴うものであるなら、それを少しでもより良くすることは意義深いことであると考えられる。
- Unified Modeling Language (UML) というものがある。（将来の）AI は UML で会話すると考えられる。これは全く安易な考えだが、自然言語より高度な抽象をもって通信されることを類推する意味では使えるだろう。
- 類推は、計算量を減少させつつ、しばしば実用上十分に正確な解をもたらす。より正確な論理と言えども、抽象化の時点について同じことが言えるのだから、あまり威張れない。現実は計算できない。
- コンピュータの上層を学ぶことは、AI の言葉を学ぶ面白みがある。
- 実際の UML は、一般的な共通の記述方法がなく、実装と同期させることにも限界があるため、理想的に汎用することはできない。数式は血が通ってこそ価値があると見ることができ、その意味で、プログラミング言語や、Python SymPy モジュールが最も上層の言語である。
- 実際の sympy は、そのような方向性の可能性を潜在させるものではあってもそういうものではないので、理想的に汎用することはできない。
- 抽象的な構造を記述してそれによって現実を自動化するという考え方は魅力的である。
- 一般的なプログラミング言語は、パフォーマンスを優先するためにそこまで抽象的な表現を用いていない。
- Lisp では、プログラム自身を操作できると聞く。そのレイヤーを少し持ち上げたものを用いると便利かもしれない。
- メモリにロードされたプログラムは、アセンブリとして表現されていると考えることができる。手続き型、命令型な表現である。命令型には宣言型が対置されると言われる。宣言型の記述が、動的に変更可能であってもいい。欲しいのは、宣言型のアセンブリが欲しいということかもしれない。
- Lisp は優れた人々に評価が高いらしいが知らない。歴史があるのに、Python などに比べて人気がないようである。実用性は低いのかもしれない。
- Python ファイルを関数とするようなシステムの組み上げ方を初歩的にでも学んでおくことは有意義である気がする。速度がいるところは C++ などを使う。
