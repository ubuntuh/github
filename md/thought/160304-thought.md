# Human Readability

### 2016-03-04 Fri

- データは様々な形式で記録（あるいは通信）される。バイナリデータ、テキストデータ、CSV (comma-separated values)、JSON (JavaScript Object Notation)、XML (Extensible Markup Language)、データベース。
- 大きな企業などによって使われる大きなデータは、データベースに記録される。同期処理などを行うためである。それぞれのデータが Unix のファイルとしてテキスト形式で保存されるのではない。Edgar F. Codd (1923-2003) が 1970 年に導出した relational database は、SQL (structured query language) を通して集合演算によって個々の用途と切り離してデータを扱うものであり、データベースの形式として支配的な地位を得た。他の形式のデータベースは、NoSQL などと呼ばれ、特定の domain で効率を求めて利用されているが、全体として見れば relational database が支配的な割合で用いられていることは変わらない。
- データベースは普通、そのままでは human readable ではない。また、Linux などの OS のファイルシステムに対して、その上にレイヤーを積み増すものであると言える。リッチなデータ形式である。
- 機械にとって、最も処理が効率的であるのは普通、バイナリデータである。ゆえに、プログラムもその多くはバイナリデータ（機械語）でコンピュータに格納されており、プロセッサはそれを解釈する。しかし、機械語は human readable ではない。
- 人間は、データを用いるにあたって、ほとんどは自動処理に用いられるデータであっても、処理効率の無駄が問題なければ、可読性と標準化を求め、human readability を求めることをしてきた。上に挙げた、テキストデータ、CSV、JSON、XML は、一応、human readable である。
- Unix に慣れた人々は、bash などのテキストシェルの、pipe と redirection という機能を用いて、コマンドを組み合わせて様々な処理を柔軟に手早くこなす。また、そうして自動化する。そのような行為を眺めていると、数秒で書ける自動処理を、他の方法でずっと長く時間をかけて実装することは、少なくとも domain によっては、生産的ではないように感じられる。
- pipe と redirection の世界では、テキストファイルがデータであり、コマンドが関数である。Unix のコマンドには、テキストデータを、例えば改行を活用する処理を行うものが多くある。標準的なコマンドを最大限に用いたならば、どこまで何ができるのだろうか？
- 世の中の進歩は、一見して感じられるほど速くない。本質的にずっと理想に近づいた OS とインタフェースや、プログラミング言語というものは、自分が生きているうちには現れないし、現れたとしても、自分が生きているうちには流行らない、枯れない。コンピュータの歴史は長く、過去の天才達が蓄積したものが多すぎる。Unix と bash と C が永遠だと考えたほうが安全である。
- shell script は、特別なインタプリタ言語である。なぜなら、Unix コマンドを直に書くことができるからである。
- bash script は、一見、嫌なものに見える。洗練されていないように見える。しかし、その目的のためには、それなりに洗練されているのである。
- Unix で、テキストデータを読むには、less コマンドがある。
- 一般の事務員が皆、情報の閲覧を less コマンドで行う会社を考えることができるだろうか？　そこに理想を見ることができるだろうか？
- ユーザインタフェースとしては、今は、web browser が便利なようである。
- bash というレイヤーの長所は、ユーザに対する道具として関数（コマンド）群が露出しているところにある。例えば、入出力が定形の形式で与えられた場合、末端の作業員は作業を自動化して効率化することができないが、bash レイヤーで与えられれば、各々に工夫の機会がある。ゆえに言わば、human computer の計算力をよく活かすことができる。
- テキストファイルがデータであり、コマンドが関数である。コマンドはまた、テキストファイル (bash script) であるかバイナリファイル (C program) である。それらデータらと関数らは、ファイルシステムの上に置かれる。ファイルシステムは普通、木構造で表される。
- データを受信するとファイルが作成される。仕事をして作成したデータは、テキストファイルとして送信用の場所に保存し、送信する。
- ユーザの作業を、関数が露出した場所で完結させたい。また、依存するレイヤーの厚さを小さくしたい。

#### -

- オブジェクト指向、例えば Java の interface において、実装や関数を隠蔽することが行われる。
- それは、依存を避けるためである。
- 何らかの framework が作られる際にも、あえて wrapper が作られることが多い。疎結合にする。疎結合、密結合という言葉がある。coupling。
- ある関数をユーザが呼んでも、設定により実際には異なる関数が呼び出されるようにするようなレイヤーを挿入することは可能である。これは、仮想化と似ている。
- ある機能がある別の機能に依存している時、その実装が更新された時には自動的に更新されたい場合が多い。しかしまた、更新しないでほしい場合も多い。
- version control system (VCS) として Git が成功した。
- version control は、あるオブジェクトが関係性を持って変化していくことを扱う。あるいは、関係性を持った分布を扱う。変化は、グラフ構造で表される。しかし普通、時間は 1 方向に進む。そこにおいて、copy と merge が行われる。
- 特定のバージョンのライブラリに依存していたいならばグラフ構造の空間の 1 点を参照しておけばよく、最新のバージョンに依存していたいならば進行する先端を参照しておけばよいのだと考えられる。
- cache は便宜であり、無限大の計算力（と無限大の情報量）に依存した実装が基本的な抽象である。
- Git では、オブジェクトそれぞれの名前はそのデータの SHA-1 ハッシュである。
- 多くの場合、依存したい、すなわち利用したいのは、仕様であって実装ではない。ゆえに、実装の名前を参照することは好ましくない。そのため、仕様に依存するものとして、インタフェースが使われる。
- 全ては、軽くあってほしい。software-defined networking (SDN) というものが行われる。機能の chain は、判断して動的に変更できるものであると便利である。軽いものは動かしやすく、重いものは動かしにくい。また、動かされやすいものは破壊されにくい。重いものは淘汰され、全てを軽くするために情報化は進行していく。アイデアや空想が主体になる。具体的な思考が価値を持つ。
- 実装は、とても面倒くさい。しかしそこを正しく整理したところに力が伴う。
- アイデア主体になると、言わば馬鹿げた素人の発想によって混乱させられる場合がある。しかしそれがかえってミーハーな顧客を得る場合がある。時代も人間も変わっていく。
- 簡単であることが好まれる。バカチョン。大多数の人々の理想は高くない。簡単に囲い込まれていく。
- しかし例えば、オープンソースは理想のみによって発展したのではない。依存を避ける企業の力が集まり、自然に優れた無料の製品が生まれる。適度の標準を公開することで、その標準がシェアを獲得でき、そこでのリーダーシップによって利益を得られる。
- 優れた人々の地位が高く、低い地位の人々は全て完全に能力がないならば、計画主義は成功する。しかし実際には、既得権益を持つ人々が能力的に腐敗することがあるし、既得権益を持たない人々の間にも様々な才能を持った子が生まれる。ゆえに市場主義が勝利しやすい。ゆえに、いかなる末端に従事する者にも十分な工夫の余地があるシステムが理想的だろう。
- そのためには、front end system のなるべく広い範囲についてオープンソースとし、back end のなるべくコアな領域について API を公開する必要があるだろう。front end system は、ユーザにとって差し替え可能である必要があるだろう。
- Smalltalk という言語があり、message passing を重視するらしい。message passing は、インターネットにおけるパケット通信に似ている。それぞれのスレッドは抽象化される。event-driven という言葉もある。
- 関数による計算については、与える引数やその結果得られる返り値をメッセージであると考えることができる。関数をオブジェクトであると考えることができる。また、世界に対して、利用したい関数とそれへの引数をメッセージとして入力するのだと考えることもできる。
- オブジェクトの名前はハッシュであると考えることができる。しかし、自然数同士の和を計算する関数において、それぞれの数を意味するハッシュを与えられたとしても、実装には困るだろう。自然数は無限個あるからである。
- インタフェースが小さいほどモジュール間は疎結合になる。すなわち、メッセージが小さいほどモジュール間は疎結合になる。
- 状態は、attribute-value pair ら (dictionary) で表される。その代表的なデータ形式の一つは JSON (JavaScript Object Notation) である。
- key-value pair で考えると、ファイル名が key でファイルの内容が value だと考えることができる。
- レイヤーは 0 であることが理想的である。
- relational database は、木構造によってデータが構造に依存することを否定した。
- relational database のコンセプトは巨大な列数を否定していない気がしなくもないが、実際のデータベースでは列数に制限があったりパフォーマンスが減少するらしい。
- One True Lookup Table (OTLT) というものと Entity Attribute Value (EAV) というものがあり、データベースの設計において基本的で典型的な誤りであるらしい。
- OTLT とは？　relational database では、例えば都道府県コードと都道府県名を列として持つ都道府県マスタというテーブルが用いられる。これは正しい。これは、しばしば多量であるコード体系それぞれについて異なるテーブルとして実装されるが、それが正しい。OTLT は、識別のために 1 つ列を追加して、これらを 1 つのテーブルに実装するものである。データが小さい場合には問題がないことも多いらしいが、避けるべきことであるらしい。
- EAV とは？　次のようなものである。
- (entity attribute value)
- entity1 attribute1 value1
- entity1 attribute2 value2
- entity2 attribute3 value3
- entity2 attribute4 value4
- 柔軟性が得られる。しかし例えば value の型をデータベースが検証できない。データが大きくなるに従ってデメリットの方がずっと大きくなる。このような柔軟性を得たいならば、そのためのデータベースを使い、relational database を使うべきではない。
- 一方で、relational database において正攻法である方法は、entity ごとに table を設けるものである。
- relational database では、属性の側に主体があると見ることができる。
- Wikipedia - Object-relational impedance mismatch というページがある。RDB は集合論であって宣言的であり、OOP はグラフ理論（木構造）であって命令的であるらしい。
- 実体関連モデル (entity-relationship model, ER model) というものがある。
- relational database は、ほとんど万能なのだろうか？
- （一般的な）operating system の file system は、なぜ（一般的な） relational database management system によって実装されていないのか？　そうすることは可能なのか？
- inode というものがある。inode number というものがある。
- 同じ内容のファイルが 2 つあることがある。集合論的には、これは 1 つだと思った方が簡単だろう。
- あるテーブルにある要素らがあるということは、ある要素らがないことを同時に表している。
- あるテーブルは、0 以上の整数だとか、0 以上の実数だとかを表すこともできると仮に考えた方が、集合論に適いそうである。内包的表現による無限の表現。
- inode は複数のリンクを持てる。それはそれとして、絶対パスとファイルが 1 対 1 に対応すると考えよう。基本的には、絶対パスを与えてファイル内容を求めるのであって、ファイル内容を与えて絶対パスを求めることはしない。テーブルには、絶対パスの列とファイル内容の列があると考えられる。絶対パスについて UNIQUE 制約を与える。
- 集合として考えると、UNIQUE 制約があるのは問題ないと思われる一方で PRIMARY KEY (PK) 制約というものがあるのは不思議な気がする。
- FOREIGN KEY (FK) 制約というものがある。他のテーブルの識別子を名指しする。重要な機能である。これによってテーブル同士が接続される。
- a b
- c d
- というテーブルは、（a かつ b）または（c かつ d）という意味である。(a and b) or (c and d)。
- C 言語などを想定して、変数を RDB に格納するなら、どのようになるのだろうか？
- グローバル変数しか存在しないと考えよう。すると深さのない key-value pair で良い気がする。ある範囲の整数でしか変数名を与えられないとしよう。
- variable name (PK) | variable value
- 1 | value1
- 2 | value2
- 型の情報も与えてみよう。
- variable name (PK) | variable type id (FK) | variable value
- 1 | 11 | value1
- 2 | 12 | value2
- RDB でどのようにして構造を表すのか？　グラフを書こう。
- src (PK) | dst (PK)
- 1 | 1
- 1 | 2
- 2 | 3
- 2 | 4
- リンクらを表すテーブル（とノードらを表すテーブル）があればグラフが表せる。
- テーブルは動的に量産したり破棄したりしてよいものなのだろうか？　その必要はないだろう。
- 木構造はどのように表せるだろうか？　木構造では、深さが 1 異なるノード同士しかリンクを持てず、親は最大 1 個である。
- 簡単なログデータはどのように RDB で表されるのだろうか？　id は付けるべきだろうか？
- time | information
- 2001-02-03 04:05 | Data changed.
- ログはコマンドと同じだろう。
- time | command
- 2001-02-03 04:05 | Load a and b and store its sum to a.
- 関数をデータとして格納できるだろうか？
- function name | function implementation
- int main(void) | { return 0; }
- あるいは、
- symbol | expression
- sum | add arguments
- あるいは、
- src func | args | dst func | args
- sum | x or y | add | x or y
- あるいは、
- src func | args | dst funcs | argss ？
- f(1) とは、f(x) の x と 1 とをリンクさせた構造だと考えられる。その構造を評価すると出力が得られる。
- lambda calculus on relational databases
- message passing and lambda calculus
- actor model, dataflow programming
- RDB は再帰的だろうか？
- table には色々制約が設定されるようであるが、それは table の外で記述されるようである。よって単純には再帰的ではないだろう。
- RDB のある状態は、ある SQL で表せる。よってその SQL を RDB に格納すれば、RDB は RDB を格納できる。その意味で再帰的である。
- しかし、データベースを SQL に変換するということは行われない？ようである。

#### -

- XML や JSON では、改行とインデントを用いると、人間にとっては読みやすくなることが多い。改行とインデントを用いないと、人間にとってはほとんど読めなくなることが多い。
- しかし、機械にとっては、改行とインデントが無いほうがわかりやすい。
- XML や JSON は（基本的に）木構造でデータを表す。木の部分はそれ自身、木である。例えば、既存の XML や JSON の一部に、与えられた XML や JSON を追加することを考えよう。追加すると、相互に既存のインデントがあったとしても、そのままでは揃わない。
- しかしそれは改行とインデントについての問題であり、XML や JSON の問題ではない。改行やインデントなく情報が表されていたならば、そのような操作は問題なく行え、追加的な調整は必要ない。
- 連想配列などによっては、極めて柔軟なデータ構造が利用できる。一方、宣言的なデータ構造では、エラーを抑制できる。安定した部分や安定させたい部分については静的な制約が好ましく、動的な周辺部分では柔軟な構造が好ましい。
- XML や JSON では、データをテキストで表そうとする。テキストは直列 (serial) である。
- 木は、簡単な方法で全てのノードを走査できる。ゆえに、テキストで JSON が表せる。
- 浅い JSON で RDB の table に相当するものを表し、それらを演算することも可能だろう。
- 例えば 1 つの JSON ファイルによっては 1 つの集合のみ表すなどすれば、JSON による木は RDB によって批判されるようなところを失い、構造への依存は view へと分離されるだろう。JSON と RDB を安易に対応させて運用することが可能になるだろう。
- RDB ないし単に DB では、view という概念がある。対義語は base table、実表であるようだ。データの実体は base table にあり、view はある演算によってそこから導かれたものである。
- 同じ view を提供する演算であっても、方法によりパフォーマンスに違いが出る。
- 制約などをデータベース側で記述するというのは、自由性に限りがあって生産的でない気がする。理想的には、非常に複雑な制約が求められるであろうが、データベースについて SQL などでそれを記述することはできないのではないだろうか？
- 制約など、データの意味についての記述は、Python などによって行ったほうがいいのではないか。
- 例えば、巨大なテーブルの値の全体を 1 度 JSON の 1 ファイルに書き出し、ある列について、Python プログラムによって、値が整数であることをテストする。これもまた不毛である気がする。verification。
- JSON で表されたテーブルの演算はどのように可能だろうか？
- Alpha language というものがある。
- jq コマンドというものがある。
- CSV (comma-separated values) というものもある。
